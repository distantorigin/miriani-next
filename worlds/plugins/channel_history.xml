<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, April 09, 2010, 3:17 PM -->
<!-- MuClient version 4.51 -->

<!-- Plugin "channel_history" generated by Plugin Wizard -->

<muclient>
<plugin
   name="channel_history"
   author="Tsp Oriol G Athlon Weyoun"
   id="6000a4c6f0e71d31fecf523d"
   language="Lua"
   purpose="Allows reading of messages sorted into buffers with hotkeys"
   date_written="2010-04-09 15:14:12"
   requires="4.51"
   version="2.0"
save_state="y"
   >
<description trim="y">
<![CDATA[
The only alias you should need is history_add. Its syntax is:
history_add category=message

Accelerator keys:
alt+1 through alt+0 - read first through tenth latest message in buffer. pressing one of these keys twice within 0.5 seconds will copy the message to the clipboard, and 3 times will paste it into the command window.
alt+Up / Down arrow: read next or previous message in buffer
Alt + page up / down: move up or down 10 messages in buffer
Alt + Home / end: Move up / down 2000 messages in buffer
Alt + Space: repeat current message
Alt + Shift + Space: Copy current message to clipboard
Alt + enter: open a URL in the current message if there is one, otherwise open world configuration
alt+shift+1-0: jump to first through tenth buffer
Alt + shift + ` (grave accent)( also works without shift): If you have some text typed in the command window, try to jump to a buffer starting with that text. Press the command with the window empty to return to where you were before the last jump. Effectively it lets you flip between two buffers this way.
Alt + Backslash: If you have some text typed in the command window, searches toward the bottom of the current buffer for that text. Add shift to search toward the top of the buffer. If a match is found, focus jumps to that message.
alt+shift+enter; copy current buffer to a notepad
alt + shift + t: toggle timestamp announcements

**NEW QUICK BUFFER SYSTEM:**
Alt + Q: Cycle through your quick list of buffers endlessly
Alt + Shift + Q: Add/remove current buffer from quick list, or remove missing buffers after "not found" messages
Commands: history_quicklist, history_quickclear

CHANGELOG:
- Added quick buffer system for fast cycling between favorite channels/buffers
- Buffers automatically announce current list when added/removed for easy management
- Missing buffer cleanup: when cycling fails to find a buffer, Alt+Shift+Q removes it from the list
- Quick list persists across client restarts

]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   script="history_delete"
   match="^history_delete"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="category_move"
   match="^history_move (\w+)"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="history_add"
   match="^history_add ([^\s=][^=]*)=(.*)"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_get"
   match="^history_get (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_link"
   match="^history_get_link"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_catjump"
   match="^history_catjump (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_catprev"
   match="history_catprev"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_catnext"
   match="history_catnext"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_msgprev"
   match="^history_msgprev (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_msgnext"
   match="^history_msgnext (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_msgcopy"
   match="history_msgcopy"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_notepad"
   match="history_notepad"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_catsearch"
   match="history_catsearch"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   match="^(|history\_)timestamps?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>if timestamps==true then
timestamps=false
SetVariable("timestamps", "false")
Execute("tts_interrupt Timestamps will no longer be spoken after messages.")
else
timestamps=true
SetVariable("timestamps", "true")
Execute("tts_interrupt You will now hear an approximate time after every message.")
end</send>
  </alias>
  <alias
   script="history_quickcycle"
   match="history_quickcycle"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_quicktoggle"
   match="history_quicktoggle"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_quicklist"
   match="^history_quicklist$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="history_quickclear"
   match="^history_quickclear$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="config_memory_window"
   match="^history_config_window (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="config_idle_save"
   match="^history_config_idle (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="manual_save"
   match="^history_save$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="show_history_stats"
   match="^history_stats$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="SPHB"
   match="^sphb\s*(.*)"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="history_get"
   match="^spr\s+(\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   match="^spc$"
   regexp="y"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   sequence="100"
   send_to="12"
>
<send>Execute("sphb copy")
</send>
  </alias>

  <alias
   script="sps_handler"
   match="^sps(?:\s+(.+))?$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
   send_to="12"
  >
  </alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
modes = {} -- for keyboard states
messages = {}
indices = {}
current_category = 0 -- not set yet
prev_category=0 --for jump
current_search=0 --for search
categories = {}
quick_buffers = {} -- configurable list of buffers for quick cycling
quick_buffer_index = 1 -- current position in quick buffer cycle
last_not_found_buffer = nil -- track the last buffer that wasn't found

-- SQLite persistence
db = nil
memory_window_size = 10000
idle_save_delay = 600    -- seconds of idle before auto-save (0 = disabled, 600 = 10 min)
dirty_messages = {}      -- per-category list of unsaved message indices
last_saved_id = {}       -- per-category highest saved msg_id
oldest_loaded_id = {}    -- per-category oldest msg_id in memory
total_count = {}         -- per-category total message count (memory + db)
save_in_progress = false
last_message_time = 0    -- for idle detection
if not GetVariable("timestamps") then
timestamps=true
DoAfterSpecial(30, "Note('You can now toggle off the new relative time announcements in channel history. Press alt+shift+t to turn it on or off. Alternatively, you can just type timestamp.')", 14)
SetVariable("timestamps", "true")
elseif GetVariable("timestamps") == "false" then
timestamps=false
Note("Channel history timestamps are disabled.")
else
timestamps=true
Note("Channel history timestamps are enabled.")
end

-- set up accelerators
for i = 1, 9 do
Accelerator("alt + " .. i, "history_get " .. i)
Accelerator("alt + shift + " .. i, "history_catjump " .. i)
end
Accelerator("alt + 0", "history_get 10") -- 10 is a special case
Accelerator("alt + shift + 0", "history_catjump 10") -- 10 is a special case
Accelerator("alt + right", "history_catnext")
Accelerator("alt + left", "history_catprev")
Accelerator("alt + down", "history_msgnext 1")
Accelerator("alt + up", "history_msgprev 1")
Accelerator("alt + pagedown", "history_msgnext 10")
Accelerator("alt + pageup", "history_msgprev 10")
Accelerator("alt + end", "history_msgnext 2000")
Accelerator("alt + home", "history_msgprev 2000")
Accelerator("shift+alt + right", "history_move right")
Accelerator("shift+alt + left", "history_move left")
Accelerator("alt+shift+delete","history_delete")
Accelerator("alt+shift+space","history_msgcopy")
Accelerator("alt+shift+enter","history_notepad")
Accelerator("alt+enter","history_get_link")
AcceleratorTo("alt+\\","history_find(1)",12)
AcceleratorTo("alt+shift+\\","history_find(0)",12)
Accelerator("alt+shift+`","history_catsearch")
Accelerator("alt+`","history_catsearch")
Accelerator("alt+shift+t","timestamps")
Accelerator("alt+q","history_quickcycle")
Accelerator("alt+shift+q","history_quicktoggle")

function history_delete(n,l,w)
 if not require_category(true) then return end
 local cat = categories[current_category]

 -- Clear from memory
 messages[cat] = nil
 indices[cat] = nil
 dirty_messages[cat] = nil
 last_saved_id[cat] = nil
 oldest_loaded_id[cat] = nil
 total_count[cat] = nil

 -- Clear from database
 if db then
  local stmt = db:prepare("DELETE FROM channel_messages WHERE category = ?")
  stmt:bind_values(cat)
  stmt:step()
  stmt:finalize()
 end

 -- Remove from quick buffers if present
 for i = #quick_buffers, 1, -1 do
  if quick_buffers[i] == cat then
   table.remove(quick_buffers, i)
   if quick_buffer_index > i then
    quick_buffer_index = quick_buffer_index - 1
   elseif quick_buffer_index > #quick_buffers then
    quick_buffer_index = 1
   end
  end
 end
 save_quick_buffers()

 table.remove(categories, current_category)
 if current_category > #categories then
  current_category = 1
 end
 if #categories > 0 then
  say(categories[current_category])
 else
  say("no more categories.")
  categories = { }
  current_category = 0
 end
end

function category_move(name, line, w)
 if not require_category(true) then return end
 name = categories[current_category]
 table.remove(categories,current_category)
 if w[1]=="right" then
  current_category = current_category + 1
  if current_category > #categories + 1 then
   current_category = 2
  end
 else
  current_category = current_category - 1
  if current_category < 1 then
   current_category = #categories
  end
 end
 table.insert(categories, current_category, name)
 save_category_order()
 say("moved.")
end

function OnPluginInstall()
 SetVariable("tts","1")

 -- Initialize database
 local db_initialized = init_database()

 -- Load settings
 memory_window_size = tonumber(GetVariable("memory_window_size")) or 10000
 idle_save_delay = tonumber(GetVariable("idle_save_delay")) or 600  -- 10 minutes

 -- Load message history from database
 if db_initialized then
   load_memory_windows()
   apply_category_order()

   -- Start idle detection timer (checks every 5 seconds)
   if idle_save_delay > 0 then
     AddTimer("history_idle_check", 0, 0, 5, "",
              timer_flag.Enabled + timer_flag.Replace + timer_flag.ActiveWhenClosed,
              "check_idle_save")
     Note(string.format("[Channel History] Idle auto-save enabled: %d seconds", idle_save_delay))
   end
 end

 -- Initialize tracking
 dirty_messages = {}
 last_saved_id = {}
 oldest_loaded_id = {}
 last_message_time = utils.timer()

 -- Load quick buffers
 load_quick_buffers()
end


function OnPluginSaveState()
  save_to_database()
  save_category_order()
  SetVariable("memory_window_size", tostring(memory_window_size))
  SetVariable("idle_save_delay", tostring(idle_save_delay))
end

function OnPluginClose()
  save_to_database()
  if db then
    db:close()
    db = nil
  end
end

function history_add(name, line, wc)
 local cat, msg = wc[1], wc[2]
 if messages[cat] == nil then
  messages[cat] = {}
  indices[cat] = 0
  table.insert(categories, cat)
  dirty_messages[cat] = {}
  total_count[cat] = 0
 end

 -- Add message to memory
 local new_msg = {
   message = msg,
   time = utils.timer(),
   msg_id = nil  -- not yet saved
 }
 table.insert(messages[cat], new_msg)
 total_count[cat] = (total_count[cat] or 0) + 1

 -- Track as dirty
 if not dirty_messages[cat] then
   dirty_messages[cat] = {}
 end
 table.insert(dirty_messages[cat], #messages[cat])

 -- Enforce memory window (keep last N in RAM)
 if #messages[cat] > memory_window_size then
   table.remove(messages[cat], 1)

   if indices[cat] > 1 then
     indices[cat] = indices[cat] - 1
   end

   -- Adjust dirty indices
   for i, dirty_idx in ipairs(dirty_messages[cat]) do
     dirty_messages[cat][i] = dirty_idx - 1
   end

   if #messages[cat] > 0 and messages[cat][1].msg_id then
     oldest_loaded_id[cat] = messages[cat][1].msg_id
   end
 end

 -- Update idle timer
 last_message_time = utils.timer()
end

-- helper function to say stuff
function say(x)
 if(GetVariable("tts")=="1") then
  Execute("tts_interrupt " .. x)
 else
  Note(x)
 end
end

-- validate category state, returns false if invalid
function require_category(need_selection)
 if #categories == 0 then
  say("no categories")
  return false
 end
 if need_selection and current_category == 0 then
  say("No category selected.")
  return false
 end
 return true
end

-- ensure index is valid (use "end" to start at newest message, default starts at oldest)
function ensure_index(pos)
 local cat = categories[current_category]
 if indices[cat] == 0 then
  if pos == "end" then
   indices[cat] = #messages[cat]
  else
   indices[cat] = 1
  end
 end
end

-- get total message count for current category (includes db messages not in memory)
function get_total_count(cat)
 cat = cat or categories[current_category]
 return total_count[cat] or #messages[cat]
end

-- announce current buffer status
function announce_status()
 say(categories[current_category] .. ": " .. indices[categories[current_category]] .. " of " .. get_total_count())
end

-- Initialize SQLite database
function init_database()
  local db_path = GetInfo(66) .. "channel_history_" .. GetWorldID() .. ".db"

  local success, result = pcall(function() return sqlite3.open(db_path) end)
  if not success then
    Note("WARNING: Channel history database unavailable. Memory-only mode.")
    return false
  end

  db = result
  db:execute("PRAGMA journal_mode=WAL;")

  -- Create tables if needed
  local table_exists = false
  for row in db:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='channel_messages'") do
    table_exists = true
  end

  if not table_exists then
    db:execute([[
      BEGIN TRANSACTION;
      CREATE TABLE channel_messages (
        msg_id INTEGER PRIMARY KEY AUTOINCREMENT,
        category VARCHAR(255) NOT NULL,
        message TEXT NOT NULL,
        timestamp REAL NOT NULL,
        created_at INTEGER DEFAULT (strftime('%s', 'now'))
      );
      CREATE INDEX idx_category_timestamp ON channel_messages(category, timestamp DESC);
      CREATE INDEX idx_category_msgid ON channel_messages(category, msg_id DESC);
      COMMIT;
    ]])
    Note("Channel history database created.")
  end

  return true
end

-- Load memory windows from database on startup
function load_memory_windows()
  if not db then return end

  -- Get categories with messages
  for row in db:nrows([[
    SELECT DISTINCT category, COUNT(*) as msg_count
    FROM channel_messages
    GROUP BY category
    ORDER BY MAX(msg_id) DESC
  ]]) do
    local cat = row.category
    total_count[cat] = row.msg_count

    if not messages[cat] then
      messages[cat] = {}
      indices[cat] = 0
      table.insert(categories, cat)
    end

    -- Load most recent N messages
    local stmt = db:prepare([[
      SELECT msg_id, message, timestamp
      FROM channel_messages
      WHERE category = ?
      ORDER BY msg_id DESC
      LIMIT ?
    ]])
    stmt:bind_values(cat, memory_window_size)

    local temp = {}
    while stmt:step() == sqlite3.ROW do
      local row = stmt:get_named_values()
      table.insert(temp, {
        message = row.message,
        time = row.timestamp,
        msg_id = row.msg_id
      })
    end
    stmt:finalize()

    -- Reverse to oldest-first
    for i = #temp, 1, -1 do
      table.insert(messages[cat], temp[i])
    end

    if #messages[cat] > 0 then
      last_saved_id[cat] = messages[cat][#messages[cat]].msg_id
      oldest_loaded_id[cat] = messages[cat][1].msg_id
    end
  end
end

-- Save dirty messages to database
function save_to_database()
  if not db or save_in_progress then return end

  save_in_progress = true

  local success, err = pcall(function()
    db:execute("BEGIN TRANSACTION")

    for cat, dirty_indices in pairs(dirty_messages) do
      if #dirty_indices > 0 then
        local stmt = db:prepare([[
          INSERT INTO channel_messages (category, message, timestamp)
          VALUES (?, ?, ?)
        ]])

        for _, idx in ipairs(dirty_indices) do
          local msg = messages[cat][idx]
          if msg and not msg.msg_id then
            stmt:bind_values(cat, msg.message, msg.time)
            stmt:step()
            msg.msg_id = db:last_insert_rowid()

            if not last_saved_id[cat] or msg.msg_id > last_saved_id[cat] then
              last_saved_id[cat] = msg.msg_id
            end

            stmt:reset()
          end
        end

        stmt:finalize()
        dirty_messages[cat] = {}
      end
    end

    db:execute("COMMIT")
  end)

  if not success then
    pcall(function() db:execute("ROLLBACK") end)
    Note("Error saving channel history: " .. tostring(err))
  end

  save_in_progress = false
end

-- Idle detection timer callback
function check_idle_save()
  if not db or idle_save_delay == 0 then return end

  local idle_time = utils.timer() - last_message_time
  if idle_time >= idle_save_delay then
    -- Check if there are unsaved messages
    local has_dirty = false
    local total_dirty = 0
    for cat, dirty_list in pairs(dirty_messages) do
      if #dirty_list > 0 then
        has_dirty = true
        total_dirty = total_dirty + #dirty_list
      end
    end

    if has_dirty then
      Note(string.format("[Channel History] Idle save triggered: %d unsaved messages", total_dirty))
      save_to_database()
    end
  end
end

-- Lazy load older messages from database when navigating backward
function lazy_load_older_messages(cat, requested_count)
  if not db or not oldest_loaded_id[cat] then
    return 0
  end

  local load_count = math.min(requested_count + 50, 200)

  local success, older_messages = pcall(function()
    local msgs = {}
    local stmt = db:prepare([[
      SELECT msg_id, message, timestamp
      FROM channel_messages
      WHERE category = ? AND msg_id < ?
      ORDER BY msg_id DESC
      LIMIT ?
    ]])
    stmt:bind_values(cat, oldest_loaded_id[cat], load_count)

    while stmt:step() == sqlite3.ROW do
      local row = stmt:get_named_values()
      table.insert(msgs, {
        message = row.message,
        time = row.timestamp,
        msg_id = row.msg_id
      })
    end
    stmt:finalize()
    return msgs
  end)

  if not success or #older_messages == 0 then
    return 0
  end

  -- Prepend to messages array (oldest first)
  for i = #older_messages, 1, -1 do
    table.insert(messages[cat], 1, older_messages[i])
  end

  oldest_loaded_id[cat] = messages[cat][1].msg_id

  -- Trim from end if needed
  while #messages[cat] > memory_window_size + load_count do
    table.remove(messages[cat])
  end

  return #older_messages
end

function history_get(name, line, wc)
 local str = ""
 if current_category == 0 and #categories == 0 then
  say("No categories")
  return
 elseif current_category == 0 and #categories > 0 then
  for i, result in ipairs(categories) do
   if categories[i] == "all" then
    current_category = i
   end
  end
  if current_category > 0 then
   str = str .. "switching to all."
  else
   str = str .. "switching to " .. categories[1] .. ". Use alt left and right arrows to change."
   current_category = 1
  end
 end
 local item = tonumber(wc[1])
 if #messages[categories[current_category]] < item then
  say("no message")
  return
 end

 -- now that all that's out of the way, we can start our real code which should always succeed.
 local timeout = 0.5 -- in seconds
 if modes[item] == nil then
  modes[item] = {utils.timer(), 1}
 elseif utils.timer()-modes[item][1] >= timeout then
  modes[item][1] = utils.timer()
  modes[item][2] = 1
 else
  modes[item][1] = utils.timer()
  modes[item][2] = modes[item][2] + 1
 end
 if modes[item][2] > 3 then
  modes[item][2] = 3
 end

 local real_item = #messages[categories[current_category]] + 1 - item
 if modes[item][2] == 1 then
  sayMsg(str, messages[categories[current_category]][real_item])
 elseif modes[item][2] == 2 then
  SetClipboard(messages[categories[current_category]][real_item]["message"])
  say("copied")
 elseif modes[item][2] == 3 then
  PasteCommand(messages[categories[current_category]][real_item]["message"])
  say("pasted")
 end
end

function history_catjump(name, line, wc)
 local cat = tonumber(wc[1])
 if not require_category(false) then return end
 if #categories < cat then
  say("That category doesn't exist yet.")
  return
 end
 current_category = cat
 if get_total_count() > 0 then ensure_index() end
 announce_status()
end

function sayMsg(str,m)
saythis=str .. " " .. m["message"]
if timestamps==true then
local lastchar=string.byte(m["message"]:sub(-1))
--print(lastchar)
if (lastchar>=49 and lastchar<=57) or (lastchar>=65 and lastchar<=91) or (lastchar>=97 and lastchar<=123) then
saythis=saythis.."."
end
saythis=saythis.." "..calculateRelativeTime(utils.timer()-m["time"])
end
say(saythis)
end
function calculateRelativeTime(t)
if t<1 then
return "just now"
end
if t>=1 and t<60 then
return math.floor(t).." seconds ago"
end
if t>=60 and t<3600 then
local min=math.floor(t/60)
local sec=math.floor(math.fmod(t,60))
if sec==0 then sec=""
else sec=sec.." seconds"
end
return min.." minutes "..sec.." ago"
end
if t>=3600 and t<86400 then -- amount of seconds in a day.
local hr=math.floor(t/3600)
local min=math.floor((t%3600)/60)
return hr.." hours "..min.." minutes ago"
end
if t>86400 then
local days=math.floor(t/86400)
local hr=math.floor((t-(86400*days))/3600)
local min=math.floor(((t-((86400*days)+(3600*hr)))/60))
return days.." days, "..hr.." hours, and "..min.." minutes ago"
end

return ""
end
function history_catnext(name, line, wc)
 if not require_category(false) then return end
 current_category = current_category + 1
 if current_category > #categories then
  current_category = 1
 end
 ensure_index()
 announce_status()
end

function history_catprev(name, line, wc)
 if not require_category(false) then return end
 current_category = current_category - 1
 if current_category < 1 then
  current_category = #categories
 end
 ensure_index()
 announce_status()
end

function history_msgnext(name, line, wc)
 local skip = tonumber(wc[1])
 local str = ""
 if not require_category(true) then return end
 ensure_index("end")
 if indices[categories[current_category]] + skip > #messages[categories[current_category]] then
  indices[categories[current_category]] = #messages[categories[current_category]]
  str = str .. "Bottom: "
 else
  indices[categories[current_category]] = indices[categories[current_category]] + skip
 end
 sayMsg(str, messages[categories[current_category]][indices[categories[current_category]]])
end

function history_msgprev(name, line, wc)
 local skip = tonumber(wc[1])
 local str = ""
 if not require_category(true) then return end
 ensure_index("end")

 local cat = categories[current_category]
 local target_index = indices[cat] - skip

 -- Try to load older messages if needed
 if target_index < 1 then
   local loaded = lazy_load_older_messages(cat, skip)
   if loaded > 0 then
     indices[cat] = indices[cat] + loaded
     target_index = target_index + loaded
     str = str .. "(Loaded " .. loaded .. " older messages) "
   end
 end

 -- Clamp to valid range
 if target_index < 1 then
  indices[cat] = 1
  str = str .. "Top: "
 else
  indices[cat] = target_index
 end

 sayMsg(str, messages[cat][indices[cat]])
end

function history_link(name, line, wc)
 if not require_category(true) then
  say("opening world configuration")
  DoAfterSpecial(1,"DoCommand('preferences')",12)
  return
 end
 ensure_index("end")
 local hmm = messages[categories[current_category]][indices[categories[current_category]]]["message"]
 local links = {}
 local re = rex.new("(http|ftp|https)://([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%!:/~+#-]*[\\w@?^=%/~+#-])?",rex.flags().CASELESS)
 re:gmatch(hmm,function(m, t)
  table.insert(links,m)
 end)
 if #links==0 then
  say("no links, opening world configuration")
  DoAfterSpecial(1,"DoCommand('preferences')",12)
 elseif #links==1 then
  say("Opening URL: "..links[1])
  OpenBrowser(links[1])
 else
  local url = utils.listbox("","Select URL",links,1)
  if url then
   OpenBrowser(links[url])
  end
 end
end
function history_msgcopy(name, line, wc)
 if not require_category(true) then return end
 ensure_index("end")
 SetClipboard(messages[categories[current_category]][indices[categories[current_category]]]["message"])
 say("copied")
end
function history_notepad()
if not require_category(true) then return end
np = categories[current_category]
local nptext="Showing "..#messages[categories[current_category]].." messages:\r\n"
for i = 1, #messages[categories[current_category]] do
if timestamps==true then
nptext = nptext.. "[" .. os.date("%c", (os.time()-utils.timer()+messages[categories[current_category]][i]["time"])) .. "] " .. messages[categories[current_category]][i]["message"].."\r\n"
else
nptext = nptext..messages[categories[current_category]][i]["message"].."\r\n"
end
end
SendToNotepad(np, nptext)
 NotepadReadOnly(np, true)
 ActivateNotepad(np)
 end
function history_catsearch(name, line, wc)
 if not require_category(false) then return end
command=GetCommand()
if #command~=0 then
possibles={}
for k, v in ipairs(categories) do
if v:sub(1,#command)==command or v:find("%f[^/]"..command,1) then
table.insert(possibles, v)
end
end
selected=0
if #possibles>1 then
what=Menu(table.concat(possibles,"|"))
elseif #possibles==1 then
what=possibles[1];
else
say("nothing found")
return
end
for k, v in ipairs(categories) do
if v==what then
selected=k
break
end
end
if selected==0 then
say("nothing found")
else
prev_category=current_category
current_category=selected
SetCommandSelection(1,#GetCommand())
PasteCommand("")
end
else
if prev_category~=0 then
temp=current_category
current_category=prev_category
prev_category=temp
else
say("No previous jump available")
end
end
if current_category==0 then current_category=1 end
ensure_index()
announce_status()
end
function history_find(next)
 if not require_category(true) then return end
if not next then next=1 end
ensure_index()
search=indices[categories[current_category]]
move=1
if next==0 then move=-1 end
command=GetCommand()
if #command~=0 then
current_search=command
end
if current_search==0 then
say("No search query.")
return
end
search=search+move
while search~=0 and search~=#messages[categories[current_category]]+1 do
str=messages[categories[current_category]][search]["message"]
if string.find(string.lower(str),string.lower(current_search),1,true) then
sayMsg("",messages[categories[current_category]][search])
if GetVariable("tts")=="1" then
Execute("tts_note "..search.." of "..get_total_count())
end
indices[categories[current_category]]=search
if #command~=0 then
SetCommandSelection(1,#GetCommand())
PasteCommand("")
end
break
end
search=search+move
end
if search==0 or search==#messages[categories[current_category]]+1 then
say("not found")
end
end

-- Load quick buffers from saved variable
function load_quick_buffers()
  local saved_buffers = GetVariable("quick_buffers")
  if saved_buffers and saved_buffers ~= "" then
    quick_buffers = {}
    for buffer in saved_buffers:gmatch("([^|]+)") do
      table.insert(quick_buffers, buffer)
    end
  end
end

-- Save quick buffers to variable
function save_quick_buffers()
  SetVariable("quick_buffers", table.concat(quick_buffers, "|"))
end

-- Save category order to variable
function save_category_order()
  SetVariable("category_order", table.concat(categories, "|"))
end

-- Apply saved category order after loading from DB
function apply_category_order()
  local saved_order = GetVariable("category_order")
  if not saved_order or saved_order == "" then return end

  -- Build lookup of current categories
  local cat_set = {}
  for _, cat in ipairs(categories) do
    cat_set[cat] = true
  end

  -- Rebuild categories in saved order
  local new_order = {}
  for cat in saved_order:gmatch("([^|]+)") do
    if cat_set[cat] then
      table.insert(new_order, cat)
      cat_set[cat] = nil
    end
  end

  -- Append any new categories not in saved order
  for _, cat in ipairs(categories) do
    if cat_set[cat] then
      table.insert(new_order, cat)
    end
  end

  categories = new_order
end

-- Cycle through quick buffers with Alt+Q
function history_quickcycle(name, line, wc)
  if #quick_buffers == 0 then
    say("No buffers in quick list. Use Alt+Shift+Q to add the current buffer.")
    return
  end

  if #quick_buffers == 1 then
    -- Only one buffer, just switch to it
    local buffer_name = quick_buffers[1]
    for i, cat in ipairs(categories) do
      if cat == buffer_name then
        current_category = i
        ensure_index()
        announce_status()
        return
      end
    end
    last_not_found_buffer = buffer_name
    say("Buffer " .. buffer_name .. " not found. Press Alt+Shift+Q to remove it.")
    return
  end

  -- Multiple buffers, cycle through them
  quick_buffer_index = quick_buffer_index + 1
  if quick_buffer_index > #quick_buffers then
    quick_buffer_index = 1
  end

  local buffer_name = quick_buffers[quick_buffer_index]

  -- Find the buffer in categories and switch to it
  for i, cat in ipairs(categories) do
    if cat == buffer_name then
      current_category = i
      ensure_index()
      announce_status()
      return
    end
  end

  last_not_found_buffer = buffer_name
  say("Buffer " .. buffer_name .. " not found. Press Alt+Shift+Q to remove it.")
end

-- Toggle current buffer in/out of quick buffers list with Alt+Shift+Q
function history_quicktoggle(name, line, wc)
  -- Check if we should remove the last not-found buffer
  if last_not_found_buffer then
    local buffer_to_remove = last_not_found_buffer
    last_not_found_buffer = nil -- clear it

    -- Find and remove the not-found buffer from quick_buffers
    local found_index = nil
    for i, buffer in ipairs(quick_buffers) do
      if buffer == buffer_to_remove then
        found_index = i
        break
      end
    end

    if found_index then
      table.remove(quick_buffers, found_index)
      save_quick_buffers()

      -- Adjust index if needed
      if quick_buffer_index > found_index then
        quick_buffer_index = quick_buffer_index - 1
      elseif quick_buffer_index == found_index and quick_buffer_index > #quick_buffers then
        quick_buffer_index = 1
      end

      if #quick_buffers == 0 then
        say("Removed missing buffer " .. buffer_to_remove .. " from quick list. No buffers remaining.")
      else
        say("Removed missing buffer " .. buffer_to_remove .. " from quick list. Current buffers: " .. table.concat(quick_buffers, ", "))
      end
    else
      say("Buffer " .. buffer_to_remove .. " was not in quick list.")
    end
    return
  end

  if not require_category(true) then return end

  local current_buffer = categories[current_category]

  -- Check if buffer is already in quick_buffers
  local found_index = nil
  for i, buffer in ipairs(quick_buffers) do
    if buffer == current_buffer then
      found_index = i
      break
    end
  end

  if found_index then
    -- Remove from quick buffers
    table.remove(quick_buffers, found_index)
    save_quick_buffers()

    -- Adjust index if needed
    if quick_buffer_index > found_index then
      quick_buffer_index = quick_buffer_index - 1
    elseif quick_buffer_index == found_index and quick_buffer_index > #quick_buffers then
      quick_buffer_index = 1
    end

    if #quick_buffers == 0 then
      say("Removed " .. current_buffer .. " from quick list. No buffers remaining.")
    else
      say("Removed " .. current_buffer .. " from quick list. Current buffers: " .. table.concat(quick_buffers, ", "))
    end
  else
    -- Add to quick buffers
    table.insert(quick_buffers, current_buffer)
    save_quick_buffers()

    -- Set index to the newly added buffer
    quick_buffer_index = #quick_buffers

    say("Added " .. current_buffer .. " to quick list. Current buffers: " .. table.concat(quick_buffers, ", "))
  end
end

-- List all quick buffers
function history_quicklist(name, line, wc)
  if #quick_buffers == 0 then
    say("No buffers in quick list.")
    return
  end

  say("Quick list (" .. #quick_buffers .. " buffers):")
  for i, buffer in ipairs(quick_buffers) do
    local marker = (i == quick_buffer_index) and " (current)" or ""
    say(i .. ". " .. buffer .. marker)
  end
end

-- Clear all quick buffers
function history_quickclear(name, line, wc)
  if #quick_buffers == 0 then
    say("No buffers in quick list to clear.")
    return
  end

  local count = #quick_buffers
  quick_buffers = {}
  quick_buffer_index = 1
  save_quick_buffers()
  say("Cleared " .. count .. " buffers from quick list.")
end

function sps_handler(name, line, wc)
  local buffer_name = wc[1]

  if not buffer_name or buffer_name == "" then
    history_catnext(name, line, wc)
  else
    buffer_name = buffer_name:match("^%s*(.-)%s*$")

    if not require_category(false) then return end

    local selected = 0
    local possibles = {}

    for k, v in ipairs(categories) do
      if v:sub(1, #buffer_name) == buffer_name or v:find("%f[^/]" .. buffer_name, 1) then
        table.insert(possibles, v)
      end
    end

    if #possibles == 0 then
      say("buffer not found")
      return
    elseif #possibles == 1 then
      for k, v in ipairs(categories) do
        if v == possibles[1] then
          selected = k
          break
        end
      end
    else
      local choice = Menu(table.concat(possibles, "|"))
      if choice then
        for k, v in ipairs(categories) do
          if v == possibles[choice] then
            selected = k
            break
          end
        end
      else
        return
      end
    end

    if selected > 0 then
      current_category = selected
      ensure_index()
      announce_status()
    else
      say("buffer not found")
    end
  end
end

function SPHB(name, line, wc)
  local subcommand = wc[1] or ""
  subcommand = string.lower(subcommand:match("^%s*(.-)%s*$"))

  if subcommand == "" then
    say("Valid arguments are back, forward, copy, read, and switch.")
    return
  end

  if subcommand == "read" or subcommand == "r" then
    history_get(name, line, {wc[2] or "1"})
  elseif subcommand == "copy" or subcommand == "c" then
    history_msgcopy(name, line, wc)
  elseif subcommand == "switch" or subcommand == "s" then
    history_catnext(name, line, wc)
  elseif subcommand == "back" or subcommand == "b" then
    history_catprev(name, line, wc)
  elseif subcommand == "forward" or subcommand == "f" then
    history_catnext(name, line, wc)
  else
    say("Valid arguments are back, forward, copy, read, and switch.")
  end
end

-- Configuration command: Set memory window size
function config_memory_window(name, line, wc)
  local new_size = tonumber(wc[1])
  if new_size < 100 or new_size > 10000 then
    Note("Memory window size must be between 100 and 10,000.")
    return
  end
  memory_window_size = new_size
  SetVariable("memory_window_size", tostring(new_size))
  Note("Memory window set to " .. new_size .. " messages per buffer.")
end

-- Configuration command: Set idle save delay
function config_idle_save(name, line, wc)
  local new_delay = tonumber(wc[1])
  if new_delay < 0 or new_delay > 600 then
    Note("Idle save delay must be between 0 and 600 seconds (0 = disabled).")
    return
  end
  idle_save_delay = new_delay
  SetVariable("idle_save_delay", tostring(new_delay))

  -- Restart/stop timer based on new setting
  if new_delay > 0 and db then
    AddTimer("history_idle_check", 0, 0, 5, "",
             timer_flag.Enabled + timer_flag.Replace + timer_flag.ActiveWhenClosed,
             "check_idle_save")
    Note("Idle save delay set to " .. new_delay .. " seconds.")
  else
    DeleteTimer("history_idle_check")
    Note("Idle auto-save disabled.")
  end
end

-- Manual save command
function manual_save(name, line, wc)
  if not db then
    Note("Database not available.")
    return
  end

  -- Count dirty messages
  local unsaved = 0
  for cat, dirty_list in pairs(dirty_messages) do
    unsaved = unsaved + #dirty_list
  end

  if unsaved == 0 then
    Note("No unsaved messages.")
    return
  end

  save_to_database()
  Note("Saved " .. unsaved .. " messages to database.")
end

-- Show history statistics
function show_history_stats()
  if not db then
    Note("Database not available.")
    return
  end

  local total_db = 0
  for row in db:rows("SELECT COUNT(*) FROM channel_messages") do
    total_db = row[1]
  end

  local total_memory = 0
  for cat, msg_list in pairs(messages) do
    total_memory = total_memory + #msg_list
  end

  local unsaved = 0
  for cat, dirty_list in pairs(dirty_messages) do
    unsaved = unsaved + #dirty_list
  end

  Note(string.format(
    "History Stats: %d buffers, %d in memory, %d in database, %d unsaved. Window: %d.",
    #categories, total_memory, total_db, unsaved, memory_window_size
  ))
end

]]>
</script>
</muclient>
