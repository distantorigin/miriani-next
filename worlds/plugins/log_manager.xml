<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="log_manager"
   author="distantorigin"
   id="23a603753436e54efaec41dc"
   language="Lua"
   purpose="Automatically manages daily log files with rotation at midnight"
   date_written="2025-10-19 16:09:00"
   requires="4.46"
   version="2.0"
   save_state="n"
   >

<description trim="y">
<![CDATA[
Log Manager - Automatic daily log rotation and search.

Features:
- Daily rotation at midnight
- Directory structure: logs/<world>/<year>/<month>/<day> <Month> <year>.txt
- Search across all logs with 'lg find <text>'
- View logs with 'lg view [days ago]'
- Import logs from other formats with 'lg import'

Type 'lg help' for commands.
]]>
</description>

</plugin>

<aliases>
<alias
   match="^lg(?:\s+(.*))?$"
   enabled="y"
   regexp="y"
   script="LogManagerCLI"
   sequence="100"
   ignore_case="y"
   omit_from_command_history="y"
   omit_from_log="y"
>
</alias>
</aliases>

<script>
<![CDATA[

local scripts = "lua/miriani/scripts/"

function mplay(file, group)
  CallPlugin("843d2f53cb3685465bda7d4a", "mplay", file, group or "notification")
end

local dialog_ok, dialog_module = pcall(require, scripts.."include/dialog")
if dialog_ok then
  dialog = dialog_module
  require(scripts.."dialog_handlers")
end

local lfs = require "lfs"
local search_term = ""
local all_search_results = {}
local current_page = 1
local PAGE_SIZE = 20

function GetWorldName()
  local world_name = WorldName()
  world_name = string.gsub(world_name, "[\\/:*?\"<>|]", "_")
  world_name = string.gsub(world_name, "%s+", "_")
  return string.lower(world_name)
end

function GetDateInfo()
  return {
    year = os.date("%Y"),
    month = os.date("%m"),
    month_name = os.date("%B"),
    day = os.date("%d"),
    full_date = os.date("%Y-%m-%d")
  }
end

function GetLogDir()
  local base = GetInfo(56) .. "logs"
  return string.gsub(base, "[/\\]$", "") .. "\\" .. GetWorldName()
end

function BuildLogPath()
  local d = GetDateInfo()
  local log_dir = GetLogDir() .. "\\" .. d.year .. "\\" .. d.month
  local log_file = log_dir .. "\\" .. d.day .. " " .. d.month_name .. " " .. d.year .. ".txt"
  return log_file, log_dir
end

function EnsureLogDirectory(log_dir)
  local path_parts = {}
  for part in string.gmatch(log_dir, "[^/\\]+") do
    table.insert(path_parts, part)
  end

  local current_path = ""
  for i, part in ipairs(path_parts) do
    current_path = (i == 1) and part or (current_path .. "\\" .. part)
    pcall(function() lfs.mkdir(current_path) end)
  end
end

function EnableLogging(state)
  SetLogOutput(state)
  SetLogInput(state)
  SetLogNotes(false)
  if not state and IsLogOpen() then
    CloseLog()
  end
end

function OpenDailyLog()
  local log_file, log_dir = BuildLogPath()
  EnsureLogDirectory(log_dir)

  if IsLogOpen() then CloseLog() end

  if OpenLog(log_file, true) == 0 then
    SetVariable("current_log_date", GetDateInfo().full_date)
    WriteLog("\n" .. string.rep("=", 70))
    WriteLog("Log opened on " .. os.date("%Y-%m-%d %H:%M:%S"))
    WriteLog(string.rep("=", 70) .. "\n")
  else
    Note("ERROR: Could not open log file: " .. log_file)
  end
end

function CheckLogRotation()
  if GetVariable("current_log_date") ~= GetDateInfo().full_date then
    Note("Date changed - rotating log file...")
    OpenDailyLog()
    BroadcastPlugin(1, "log_rotated")
  end
end

function OnPluginInstall()
  if not GetVariable("current_log_date") then
    SetVariable("current_log_date", "")
  end
  EnableLogging(true)
  AddTimer("log_rotation_check", 0, 0, 0, "",
    timer_flag.Enabled + timer_flag.AtTime + timer_flag.ActiveWhenClosed + timer_flag.Replace + timer_flag.Temporary,
    "CheckLogRotation")
  if IsConnected() then OpenDailyLog() end
end

function OnPluginConnect()
  OpenDailyLog()
end

function OnPluginDisconnect()
  if IsLogOpen() then
    WriteLog("\n" .. string.rep("=", 70))
    WriteLog("Log closed on " .. os.date("%Y-%m-%d %H:%M:%S"))
    WriteLog(string.rep("=", 70) .. "\n")
    CloseLog()
  end
end

function OnPluginClose()
  if IsLogOpen() then CloseLog() end
  EnableLogging(false)
end

function GetAllLogFiles()
  local world_log_dir = GetLogDir()
  local files = {}

  local function scan_dir(dir)
    local attr = lfs.attributes(dir)
    if not attr or attr.mode ~= "directory" then return end

    pcall(function()
      for entry in lfs.dir(dir) do
        if entry ~= "." and entry ~= ".." then
          local path = dir .. "\\" .. entry
          local entry_attr = lfs.attributes(path)
          if entry_attr then
            if entry_attr.mode == "directory" then
              scan_dir(path)
            elseif entry:match("%.txt$") then
              table.insert(files, { path = path, modification = entry_attr.modification, size = entry_attr.size })
            end
          end
        end
      end
    end)
  end

  scan_dir(world_log_dir)
  table.sort(files, function(a, b) return a.modification > b.modification end)
  return files
end

function SearchLogFile(file_path, term, max_hits)
  max_hits = max_hits or 3
  local results = {}
  local f = io.open(file_path, "r")
  if not f then return results end

  local line_num = 0
  local term_lower = term:lower()

  for line in f:lines() do
    line_num = line_num + 1
    if line:lower():find(term_lower, 1, true) then
      table.insert(results, { file = file_path, line_num = line_num, text = line })
      if #results >= max_hits then break end
    end
  end

  f:close()
  return results
end

function SearchAllLogs(term)
  local all_results = {}
  for _, file_info in ipairs(GetAllLogFiles()) do
    for _, result in ipairs(SearchLogFile(file_info.path, term, 3)) do
      table.insert(all_results, result)
    end
  end
  return all_results
end

function GetDaysAgoFromPath(file_path)
  local day, month_name, year = file_path:match("(%d+) (%w+) (%d+)%.txt$")
  if not day then return nil, nil end

  local months = {
    January=1, February=2, March=3, April=4, May=5, June=6,
    July=7, August=8, September=9, October=10, November=11, December=12
  }
  local month = months[month_name]
  if not month then return nil, nil end

  local log_time = os.time({year=tonumber(year), month=month, day=tonumber(day)})
  local today = os.time({year=tonumber(os.date("%Y")), month=tonumber(os.date("%m")), day=tonumber(os.date("%d"))})
  local days_ago = math.floor((today - log_time) / 86400)

  return days_ago, string.format("%s %s %s", day, month_name, year)
end

function FormatDaysAgo(days_ago)
  if days_ago == 0 then return "Today"
  elseif days_ago == 1 then return "1 day ago"
  else return string.format("%d days ago", days_ago)
  end
end

function DisplaySearchPage(page)
  current_page = page
  local total_pages = math.ceil(#all_search_results / PAGE_SIZE)
  local start_idx = (page - 1) * PAGE_SIZE + 1
  local end_idx = math.min(page * PAGE_SIZE, #all_search_results)

  local choices = {}
  for i = start_idx, end_idx do
    local result = all_search_results[i]
    local days_ago = GetDaysAgoFromPath(result.file)
    local when = FormatDaysAgo(days_ago)
    local text = result.text:sub(1, 100)
    if #result.text > 100 then text = text .. "..." end
    choices[tostring(i)] = {
      label = string.format("%s: %s", when, text),
      file = result.file,
      line_num = result.line_num
    }
  end

  local nav_idx = end_idx + 1
  if page > 1 then
    choices[tostring(nav_idx)] = { label = "Previous page", nav = "prev" }
    nav_idx = nav_idx + 1
  end
  if page < total_pages then
    choices[tostring(nav_idx)] = { label = "Next page", nav = "next" }
  end

  dialog.menu({
    title = string.format("Found %d match%s for '%s' (page %d/%d):",
      #all_search_results, #all_search_results == 1 and "" or "es", search_term, page, total_pages),
    choices = choices,
    callback = function(result, reason)
      if result and result.value then
        if result.value.nav == "next" then
          DisplaySearchPage(current_page + 1)
        elseif result.value.nav == "prev" then
          DisplaySearchPage(current_page - 1)
        else
          utils.shellexecute(result.value.file, "", "", "open", 1)
          Note("Opened log. Result is on line " .. result.value.line_num)
        end
      end
    end
  })
end

function DisplaySearchResults(results)
  if #results == 0 then
    Note("No matches found for: " .. search_term)
    return
  end

  if not dialog then
    Note("Dialog system not available. Results:")
    for i, result in ipairs(results) do
      Note(string.format("[%d] %s: %s", i, FormatDaysAgo(GetDaysAgoFromPath(result.file)), result.text:sub(1, 100)))
    end
    return
  end

  all_search_results = results
  DisplaySearchPage(1)
end

function PerformLogSearch(term)
  search_term = term
  if IsLogOpen() then FlushLog() end

  local files = GetAllLogFiles()
  Note(string.format("Searching %d log files for: %s", #files, term))

  DisplaySearchResults(SearchAllLogs(term))
end

function ParseArgs(input)
  local args = {}
  if not input or input == "" then return args end
  for word in input:gmatch("%S+") do
    table.insert(args, word)
  end
  return args
end

function ShowHelp()
  Note("Log Manager Commands:")
  Note("  lg view           Open today's log in your text editor")
  Note("  lg view <days>    Open log from N days ago")
  Note("  lg find <text>    Search all logs for text")
  Note("  lg stats          Show log statistics")
  Note("  lg toggle         Enable/disable logging")
  Note("  lg import         Rename log files to Miriani Next style")
  Note("  lg help           Show this help")
end

function CmdView(args)
  local days = tonumber(args[2])
  if days then
    local target_time = os.time() - (days * 86400)
    local target_date = {
      year = os.date("%Y", target_time),
      month = os.date("%m", target_time),
      month_name = os.date("%B", target_time),
      day = os.date("%d", target_time)
    }

    local log_file = GetLogDir() .. "\\" .. target_date.year .. "\\" .. target_date.month .. "\\" ..
                     target_date.day .. " " .. target_date.month_name .. " " .. target_date.year .. ".txt"

    if not lfs.attributes(log_file) then
      Note("No log file exists for " .. target_date.month_name .. " " .. target_date.day .. ".")
      return
    end

    Note("Opening log from " .. days .. " day" .. (days == 1 and "" or "s") .. " ago...")
    utils.shellexecute(log_file, "", "", "open", 1)
  else
    local current_log = GetInfo(51)
    if not current_log or current_log == "" then
      Note("No log file is currently set.")
      return
    end

    if IsLogOpen() then FlushLog() end

    if not lfs.attributes(current_log) then
      Note("Log file does not exist.")
      return
    end

    Note("Opening today's log...")
    utils.shellexecute(current_log, "", "", "open", 1)
  end
end

function CmdFind(args)
  local term = table.concat(args, " ", 2)
  if term == "" then
    if not dialog then
      Note("Dialog system not available. Usage: lg find <text>")
      return
    end
    dialog.prompt({
      title = "Log Search",
      callback = function(result, reason)
        if result and result.value and result.value ~= "" then
          PerformLogSearch(result.value)
        end
      end
    })
  else
    PerformLogSearch(term)
  end
end

function CountLines(file_path)
  local count = 0
  local f = io.open(file_path, "r")
  if f then
    for _ in f:lines() do count = count + 1 end
    f:close()
  end
  return count
end

function FormatSize(bytes)
  if bytes > 1048576 then return string.format("%.1f MB", bytes / 1048576)
  elseif bytes > 1024 then return string.format("%.1f KB", bytes / 1024)
  else return string.format("%d bytes", bytes)
  end
end

function CmdStats()
  local files = GetAllLogFiles()
  local total_size, total_lines = 0, 0
  local oldest_date, newest_date

  Note("Calculating log statistics...")

  for _, file in ipairs(files) do
    total_size = total_size + (file.size or 0)
    total_lines = total_lines + CountLines(file.path)
    local days_ago = GetDaysAgoFromPath(file.path)
    if days_ago then
      if not oldest_date or days_ago > oldest_date then oldest_date = days_ago end
      if not newest_date or days_ago < newest_date then newest_date = days_ago end
    end
  end

  local avg_lines = #files > 0 and math.floor(total_lines / #files) or 0
  local avg_size = #files > 0 and math.floor(total_size / #files) or 0

  Note("Log Statistics for " .. GetWorldName() .. ":")
  Note("  Logging: " .. (IsLogOpen() and "enabled" or "disabled"))
  Note("  Total log files: " .. #files)
  Note("  Total size: " .. FormatSize(total_size))
  Note("  Average size per log: " .. FormatSize(avg_size))
  Note("  Total lines: " .. total_lines)
  Note("  Average lines per log: " .. avg_lines)
  if oldest_date then
    Note("  Date range: " .. oldest_date .. " days ago to " .. (newest_date == 0 and "today" or newest_date .. " days ago"))
  end
  Note("  Log directory: " .. GetLogDir())
end

function CmdToggle()
  if IsLogOpen() then
    EnableLogging(false)
    Note("Session logging disabled.")
  else
    EnableLogging(true)
    OpenDailyLog()
    Note("Session logging enabled.")
  end
end

local month_names = {
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
}

local month_abbr_to_num = {
  jan=1, feb=2, mar=3, apr=4, may=5, jun=6,
  jul=7, aug=8, sep=9, oct=10, nov=11, dec=12
}

local month_name_to_num = {
  january=1, february=2, march=3, april=4, may=5, june=6,
  july=7, august=8, september=9, october=10, november=11, december=12
}

function IsMirianiNextStyle(filename)
  return filename:match("^%d%d? %a+ %d%d%d%d%.txt$") ~= nil
end

function ParseDateFromFilename(filename, dir_path)
  local base = filename:gsub("%.txt$", "")
  local year, month, day

  -- YYYY-MM-DD or YYYY_MM_DD
  year, month, day = base:match("^(%d%d%d%d)[_%-](%d%d?)[_%-](%d%d?)$")
  if year then return tonumber(year), tonumber(month), tonumber(day) end

  -- DD-MM-YYYY or DD_MM_YYYY
  day, month, year = base:match("^(%d%d?)[_%-](%d%d?)[_%-](%d%d%d%d)$")
  if year then return tonumber(year), tonumber(month), tonumber(day) end

  -- "December 14 2025" or "December_14_2025"
  local month_str
  month_str, day, year = base:match("^(%a+)[_% ](%d%d?)[_%, ]+(%d%d%d%d)$")
  if month_str then
    local m = month_name_to_num[month_str:lower()] or month_abbr_to_num[month_str:lower():sub(1,3)]
    if m then return tonumber(year), m, tonumber(day) end
  end

  -- "14_December_2025"
  day, month_str, year = base:match("^(%d%d?)[_% ](%a+)[_% ](%d%d%d%d)$")
  if month_str then
    local m = month_name_to_num[month_str:lower()] or month_abbr_to_num[month_str:lower():sub(1,3)]
    if m then return tonumber(year), m, tonumber(day) end
  end

  -- MM-DD-YYYY
  local m1, d1
  m1, d1, year = base:match("^(%d%d?)[_%-](%d%d?)[_%-](%d%d%d%d)$")
  if year and tonumber(m1) <= 12 and tonumber(d1) <= 31 then
    return tonumber(year), tonumber(m1), tonumber(d1)
  end

  -- YYYYMMDD
  year, month, day = base:match("^(%d%d%d%d)(%d%d)(%d%d)$")
  if year then return tonumber(year), tonumber(month), tonumber(day) end

  -- Day with ordinal (e.g. "9th, on port 1234") - get year/month from directory path
  day = base:match("^(%d%d?)%a*[,]?")
  if day and dir_path then
    year, month = dir_path:match("[/\\](%d%d%d%d)[/\\](%d%d?)[/\\]?$")
    if year and month then
      return tonumber(year), tonumber(month), tonumber(day)
    end
    local month_name_match
    year, month_name_match = dir_path:match("[/\\](%d%d%d%d)[/\\](%a+)[/\\]?$")
    if year and month_name_match then
      local m = month_name_to_num[month_name_match:lower()] or month_abbr_to_num[month_name_match:lower():sub(1,3)]
      if m then return tonumber(year), m, tonumber(day) end
    end
  end

  return nil
end

function BuildMirianiNextFilename(year, month, day)
  return string.format("%d %s %d.txt", day, month_names[month], year)
end

function BuildMirianiNextPath(year, month, day)
  local log_dir = GetLogDir() .. "\\" .. year .. "\\" .. string.format("%02d", month)
  local filename = BuildMirianiNextFilename(year, month, day)
  return log_dir .. "\\" .. filename, log_dir
end

function DoImportScan()
  local world_log_dir = GetLogDir()
  local files_to_rename = {}
  local files_with_conflicts = {}
  local skipped = 0
  local already_correct = 0

  Note("Scanning for log files to import in: " .. world_log_dir)

  local function scan_dir(dir)
    local attr = lfs.attributes(dir)
    if not attr or attr.mode ~= "directory" then return end

    pcall(function()
      for entry in lfs.dir(dir) do
        if entry ~= "." and entry ~= ".." then
          local path = dir .. "\\" .. entry
          local entry_attr = lfs.attributes(path)
          if entry_attr then
            if entry_attr.mode == "directory" then
              scan_dir(path)
            elseif entry:match("%.txt$") then
              if IsMirianiNextStyle(entry) then
                already_correct = already_correct + 1
              else
                local year, month, day = ParseDateFromFilename(entry, dir)
                if year and month and day and month >= 1 and month <= 12 and day >= 1 and day <= 31 then
                  local new_path, new_dir = BuildMirianiNextPath(year, month, day)
                  local file_info = {
                    old_path = path,
                    old_name = entry,
                    new_path = new_path,
                    new_dir = new_dir,
                    year = year,
                    month = month,
                    day = day
                  }
                  if lfs.attributes(new_path) then
                    table.insert(files_with_conflicts, file_info)
                  else
                    table.insert(files_to_rename, file_info)
                  end
                else
                  skipped = skipped + 1
                  Note("  Skipped (could not parse date): " .. entry)
                end
              end
            end
          end
        end
      end
    end)
  end

  scan_dir(world_log_dir)

  if #files_to_rename == 0 and #files_with_conflicts == 0 then
    Note("No files to import.")
    Note("  Already in correct format: " .. already_correct)
    Note("  Could not parse: " .. skipped)
    return
  end

  local function do_renames(files, overwrite)
    local renamed = 0
    local errors = 0
    local dirs_to_clean = {}
    for _, file in ipairs(files) do
      EnsureLogDirectory(file.new_dir)
      if overwrite and lfs.attributes(file.new_path) then
        os.remove(file.new_path)
      end
      local old_dir = file.old_path:match("^(.+)\\[^\\]+$")
      local ok, err = os.rename(file.old_path, file.new_path)
      if ok then
        renamed = renamed + 1
        if old_dir then dirs_to_clean[old_dir] = true end
      else
        errors = errors + 1
        Note("  Error renaming " .. file.old_name .. ": " .. (err or "unknown error"))
      end
    end
    -- Clean up empty directories
    for dir, _ in pairs(dirs_to_clean) do
      pcall(function()
        lfs.rmdir(dir)
        -- Try parent too (e.g., year folder if month folder was removed)
        local parent = dir:match("^(.+)\\[^\\]+$")
        if parent then lfs.rmdir(parent) end
      end)
    end
    return renamed, errors
  end

  if #files_to_rename > 0 then
    Note(string.format("Found %d file(s) to rename:", #files_to_rename))
    for _, file in ipairs(files_to_rename) do
      local new_name = BuildMirianiNextFilename(file.year, file.month, file.day)
      Note(string.format("  %s -> %s", file.old_name, new_name))
    end
  end

  if #files_with_conflicts > 0 then
    Note(string.format("Found %d file(s) with conflicts (destination exists):", #files_with_conflicts))
    for _, file in ipairs(files_with_conflicts) do
      local new_name = BuildMirianiNextFilename(file.year, file.month, file.day)
      Note(string.format("  %s -> %s (EXISTS)", file.old_name, new_name))
    end
  end

  if not dialog then
    local renamed, errors = do_renames(files_to_rename, false)
    Note(string.format("Import complete: %d renamed, %d errors, %d already correct, %d skipped, %d conflicts (skipped)",
      renamed, errors, already_correct, skipped, #files_with_conflicts))
  else
    local function finish_import(include_conflicts, overwrite_conflicts)
      local total_renamed = 0
      local total_errors = 0
      local renamed, errors = do_renames(files_to_rename, false)
      total_renamed = total_renamed + renamed
      total_errors = total_errors + errors
      if include_conflicts then
        renamed, errors = do_renames(files_with_conflicts, overwrite_conflicts)
        total_renamed = total_renamed + renamed
        total_errors = total_errors + errors
      end

      local conflict_msg = ""
      if #files_with_conflicts > 0 and not include_conflicts then
        conflict_msg = string.format(", %d conflicts skipped", #files_with_conflicts)
      end

      Note(string.format("Import complete: %d renamed, %d errors, %d already correct, %d skipped%s",
        total_renamed, total_errors, already_correct, skipped, conflict_msg))
    end

    if #files_with_conflicts > 0 then
      dialog.menu({
        title = string.format("%d file(s) have conflicts. Both old and new format logs exist for the same date.", #files_with_conflicts),
        choices = {
          ["1"] = { label = "Skip conflicts, only rename non-conflicting files", action = "skip" },
          ["2"] = { label = "Overwrite existing files with old format versions", action = "overwrite" },
          ["3"] = { label = "Cancel import", action = "cancel" },
        },
        callback = function(result, reason)
          if not result or not result.value or result.value.action == "cancel" then
            Note("Import cancelled.")
            return
          end

          if #files_to_rename == 0 and result.value.action == "skip" then
            Note("No non-conflicting files to import.")
            return
          end

          if result.value.action == "skip" then
            finish_import(false, false)
          elseif result.value.action == "overwrite" then
            finish_import(true, true)
          end
        end
      })
    else
      dialog.confirm({
        title = string.format("Import %d log file(s)?", #files_to_rename),
        text = "This will rename files to match Miriani Next naming convention.",
        callback = function(result, reason)
          if result and result.value then
            finish_import(false, false)
          else
            Note("Import cancelled.")
          end
        end
      })
    end
  end
end

function CmdImport(args)
  local world_log_dir = GetLogDir()

  Note("Import Log Files")
  Note("================")
  Note("This command imports logs from other clients (Proxiani, MudMixer, etc.)")
  Note("and renames them to match the Miriani Next naming convention.")
  Note("")
  Note("To import logs:")
  Note("  1. Find your old log files (must be .txt files)")
  Note("  2. Copy them into: " .. world_log_dir)
  Note("  3. Run 'lg import' again")
  Note("")

  if not dialog then
    Note("Starting scan...")
    DoImportScan()
  else
    dialog.confirm({
      title = "Ready to scan for importable logs?",
      callback = function(result, reason)
        if result and result.value then
          DoImportScan()
        else
          Note("Import cancelled.")
        end
      end
    })
  end
end

local commands = {
  view = { func = CmdView },
  log = { func = CmdView },
  open = { func = CmdView },
  find = { func = CmdFind },
  stats = { func = CmdStats },
  toggle = { func = CmdToggle },
  import = { func = CmdImport },
  help = { func = ShowHelp },
}

function LogManagerCLI(name, line, wildcards)
  local args = ParseArgs(wildcards[1] or "")
  local cmd = args[1] and args[1]:lower() or nil

  if not cmd then
    ShowHelp()
  elseif commands[cmd] then
    commands[cmd].func(args)
  else
    Note("Unknown command: " .. cmd .. ". Type 'lg help' for commands.")
  end
end

]]>
</script>

</muclient>
