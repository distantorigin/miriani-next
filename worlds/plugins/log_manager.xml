<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="log_manager"
   author="distantorigin"
   id="23a603753436e54efaec41dc"
   language="Lua"
   purpose="Automatically manages daily log files with rotation at midnight"
   date_written="2025-10-19 16:09:00"
   requires="4.46"
   version="2.0"
   save_state="n"
   >

<description trim="y">
<![CDATA[
Log Manager - Automatic daily log rotation and search.

Features:
- Daily rotation at midnight
- Directory structure: logs/<world>/<year>/<month>/<day> <Month> <year>.txt
- Search across all logs with 'lg find <text>'
- View logs with 'lg view [days ago]'

Type 'lg help' for commands.
]]>
</description>

</plugin>

<aliases>
<alias
   match="^lg(?:\s+(.*))?$"
   enabled="y"
   regexp="y"
   script="LogManagerCLI"
   sequence="100"
   ignore_case="y"
   omit_from_command_history="y"
   omit_from_log="y"
>
</alias>
</aliases>

<script>
<![CDATA[

local scripts = "lua/miriani/scripts/"

function mplay(file, group)
  CallPlugin("843d2f53cb3685465bda7d4a", "mplay", file, group or "notification")
end

local dialog_ok, dialog_module = pcall(require, scripts.."include/dialog")
if dialog_ok then
  dialog = dialog_module
  require(scripts.."dialog_handlers")
end

local lfs = require "lfs"
local search_term = ""
local all_search_results = {}
local current_page = 1
local PAGE_SIZE = 20

function GetWorldName()
  local world_name = WorldName()
  world_name = string.gsub(world_name, "[\\/:*?\"<>|]", "_")
  world_name = string.gsub(world_name, "%s+", "_")
  return string.lower(world_name)
end

function GetDateInfo()
  return {
    year = os.date("%Y"),
    month = os.date("%m"),
    month_name = os.date("%B"),
    day = os.date("%d"),
    full_date = os.date("%Y-%m-%d")
  }
end

function GetLogDir()
  local base = GetInfo(56) .. "logs"
  return string.gsub(base, "[/\\]$", "") .. "\\" .. GetWorldName()
end

function BuildLogPath()
  local d = GetDateInfo()
  local log_dir = GetLogDir() .. "\\" .. d.year .. "\\" .. d.month
  local log_file = log_dir .. "\\" .. d.day .. " " .. d.month_name .. " " .. d.year .. ".txt"
  return log_file, log_dir
end

function EnsureLogDirectory(log_dir)
  local path_parts = {}
  for part in string.gmatch(log_dir, "[^/\\]+") do
    table.insert(path_parts, part)
  end

  local current_path = ""
  for i, part in ipairs(path_parts) do
    current_path = (i == 1) and part or (current_path .. "\\" .. part)
    pcall(function() lfs.mkdir(current_path) end)
  end
end

function EnableLogging(state)
  SetLogOutput(state)
  SetLogInput(state)
  SetLogNotes(false)
  if not state and IsLogOpen() then
    CloseLog()
  end
end

function OpenDailyLog()
  local log_file, log_dir = BuildLogPath()
  EnsureLogDirectory(log_dir)

  if IsLogOpen() then CloseLog() end

  if OpenLog(log_file, true) == 0 then
    SetVariable("current_log_date", GetDateInfo().full_date)
    WriteLog("\n" .. string.rep("=", 70))
    WriteLog("Log opened on " .. os.date("%Y-%m-%d %H:%M:%S"))
    WriteLog(string.rep("=", 70) .. "\n")
  else
    Note("ERROR: Could not open log file: " .. log_file)
  end
end

function CheckLogRotation()
  if GetVariable("current_log_date") ~= GetDateInfo().full_date then
    Note("Date changed - rotating log file...")
    OpenDailyLog()
    BroadcastPlugin(1, "log_rotated")
  end
end

function OnPluginInstall()
  if not GetVariable("current_log_date") then
    SetVariable("current_log_date", "")
  end
  EnableLogging(true)
  AddTimer("log_rotation_check", 0, 0, 0, "",
    timer_flag.Enabled + timer_flag.AtTime + timer_flag.ActiveWhenClosed + timer_flag.Replace + timer_flag.Temporary,
    "CheckLogRotation")
  if IsConnected() then OpenDailyLog() end
end

function OnPluginConnect()
  OpenDailyLog()
end

function OnPluginDisconnect()
  if IsLogOpen() then
    WriteLog("\n" .. string.rep("=", 70))
    WriteLog("Log closed on " .. os.date("%Y-%m-%d %H:%M:%S"))
    WriteLog(string.rep("=", 70) .. "\n")
    CloseLog()
  end
end

function OnPluginClose()
  if IsLogOpen() then CloseLog() end
  EnableLogging(false)
end

function GetAllLogFiles()
  local world_log_dir = GetLogDir()
  local files = {}

  local function scan_dir(dir)
    local attr = lfs.attributes(dir)
    if not attr or attr.mode ~= "directory" then return end

    pcall(function()
      for entry in lfs.dir(dir) do
        if entry ~= "." and entry ~= ".." then
          local path = dir .. "\\" .. entry
          local entry_attr = lfs.attributes(path)
          if entry_attr then
            if entry_attr.mode == "directory" then
              scan_dir(path)
            elseif entry:match("%.txt$") then
              table.insert(files, { path = path, modification = entry_attr.modification, size = entry_attr.size })
            end
          end
        end
      end
    end)
  end

  scan_dir(world_log_dir)
  table.sort(files, function(a, b) return a.modification > b.modification end)
  return files
end

function SearchLogFile(file_path, term, max_hits)
  max_hits = max_hits or 3
  local results = {}
  local f = io.open(file_path, "r")
  if not f then return results end

  local line_num = 0
  local term_lower = term:lower()

  for line in f:lines() do
    line_num = line_num + 1
    if line:lower():find(term_lower, 1, true) then
      table.insert(results, { file = file_path, line_num = line_num, text = line })
      if #results >= max_hits then break end
    end
  end

  f:close()
  return results
end

function SearchAllLogs(term)
  local all_results = {}
  for _, file_info in ipairs(GetAllLogFiles()) do
    for _, result in ipairs(SearchLogFile(file_info.path, term, 3)) do
      table.insert(all_results, result)
    end
  end
  return all_results
end

function GetDaysAgoFromPath(file_path)
  local day, month_name, year = file_path:match("(%d+) (%w+) (%d+)%.txt$")
  if not day then return nil, nil end

  local months = {
    January=1, February=2, March=3, April=4, May=5, June=6,
    July=7, August=8, September=9, October=10, November=11, December=12
  }
  local month = months[month_name]
  if not month then return nil, nil end

  local log_time = os.time({year=tonumber(year), month=month, day=tonumber(day)})
  local today = os.time({year=tonumber(os.date("%Y")), month=tonumber(os.date("%m")), day=tonumber(os.date("%d"))})
  local days_ago = math.floor((today - log_time) / 86400)

  return days_ago, string.format("%s %s %s", day, month_name, year)
end

function FormatDaysAgo(days_ago)
  if days_ago == 0 then return "Today"
  elseif days_ago == 1 then return "1 day ago"
  else return string.format("%d days ago", days_ago)
  end
end

function DisplaySearchPage(page)
  current_page = page
  local total_pages = math.ceil(#all_search_results / PAGE_SIZE)
  local start_idx = (page - 1) * PAGE_SIZE + 1
  local end_idx = math.min(page * PAGE_SIZE, #all_search_results)

  local choices = {}
  for i = start_idx, end_idx do
    local result = all_search_results[i]
    local days_ago = GetDaysAgoFromPath(result.file)
    local when = FormatDaysAgo(days_ago)
    local text = result.text:sub(1, 100)
    if #result.text > 100 then text = text .. "..." end
    choices[tostring(i)] = {
      label = string.format("%s: %s", when, text),
      file = result.file,
      line_num = result.line_num
    }
  end

  local nav_idx = end_idx + 1
  if page > 1 then
    choices[tostring(nav_idx)] = { label = "Previous page", nav = "prev" }
    nav_idx = nav_idx + 1
  end
  if page < total_pages then
    choices[tostring(nav_idx)] = { label = "Next page", nav = "next" }
  end

  dialog.menu({
    title = string.format("Found %d match%s for '%s' (page %d/%d):",
      #all_search_results, #all_search_results == 1 and "" or "es", search_term, page, total_pages),
    choices = choices,
    callback = function(result, reason)
      if result and result.value then
        if result.value.nav == "next" then
          DisplaySearchPage(current_page + 1)
        elseif result.value.nav == "prev" then
          DisplaySearchPage(current_page - 1)
        else
          utils.shellexecute(result.value.file, "", "", "open", 1)
          Note("Opened log. Result is on line " .. result.value.line_num)
        end
      end
    end
  })
end

function DisplaySearchResults(results)
  if #results == 0 then
    Note("No matches found for: " .. search_term)
    return
  end

  if not dialog then
    Note("Dialog system not available. Results:")
    for i, result in ipairs(results) do
      Note(string.format("[%d] %s: %s", i, FormatDaysAgo(GetDaysAgoFromPath(result.file)), result.text:sub(1, 100)))
    end
    return
  end

  all_search_results = results
  DisplaySearchPage(1)
end

function PerformLogSearch(term)
  search_term = term
  if IsLogOpen() then FlushLog() end

  local files = GetAllLogFiles()
  Note(string.format("Searching %d log files for: %s", #files, term))

  DisplaySearchResults(SearchAllLogs(term))
end

function ParseArgs(input)
  local args = {}
  if not input or input == "" then return args end
  for word in input:gmatch("%S+") do
    table.insert(args, word)
  end
  return args
end

function ShowHelp()
  Note("Log Manager Commands:")
  Note("  lg view           Open today's log in your text editor")
  Note("  lg view <days>    Open log from N days ago")
  Note("  lg find <text>    Search all logs for text")
  Note("  lg stats          Show log statistics")
  Note("  lg toggle         Enable/disable logging")
  Note("  lg help           Show this help")
end

function CmdView(args)
  local days = tonumber(args[2])
  if days then
    local target_time = os.time() - (days * 86400)
    local target_date = {
      year = os.date("%Y", target_time),
      month = os.date("%m", target_time),
      month_name = os.date("%B", target_time),
      day = os.date("%d", target_time)
    }

    local log_file = GetLogDir() .. "\\" .. target_date.year .. "\\" .. target_date.month .. "\\" ..
                     target_date.day .. " " .. target_date.month_name .. " " .. target_date.year .. ".txt"

    if not lfs.attributes(log_file) then
      Note("No log file exists for " .. target_date.month_name .. " " .. target_date.day .. ".")
      return
    end

    Note("Opening log from " .. days .. " day" .. (days == 1 and "" or "s") .. " ago...")
    utils.shellexecute(log_file, "", "", "open", 1)
  else
    local current_log = GetInfo(51)
    if not current_log or current_log == "" then
      Note("No log file is currently set.")
      return
    end

    if IsLogOpen() then FlushLog() end

    if not lfs.attributes(current_log) then
      Note("Log file does not exist.")
      return
    end

    Note("Opening today's log...")
    utils.shellexecute(current_log, "", "", "open", 1)
  end
end

function CmdFind(args)
  local term = table.concat(args, " ", 2)
  if term == "" then
    if not dialog then
      Note("Dialog system not available. Usage: lg find <text>")
      return
    end
    dialog.prompt({
      title = "Log Search",
      callback = function(result, reason)
        if result and result.value and result.value ~= "" then
          PerformLogSearch(result.value)
        end
      end
    })
  else
    PerformLogSearch(term)
  end
end

function CountLines(file_path)
  local count = 0
  local f = io.open(file_path, "r")
  if f then
    for _ in f:lines() do count = count + 1 end
    f:close()
  end
  return count
end

function FormatSize(bytes)
  if bytes > 1048576 then return string.format("%.1f MB", bytes / 1048576)
  elseif bytes > 1024 then return string.format("%.1f KB", bytes / 1024)
  else return string.format("%d bytes", bytes)
  end
end

function CmdStats()
  local files = GetAllLogFiles()
  local total_size, total_lines = 0, 0
  local oldest_date, newest_date

  Note("Calculating log statistics...")

  for _, file in ipairs(files) do
    total_size = total_size + (file.size or 0)
    total_lines = total_lines + CountLines(file.path)
    local days_ago = GetDaysAgoFromPath(file.path)
    if days_ago then
      if not oldest_date or days_ago > oldest_date then oldest_date = days_ago end
      if not newest_date or days_ago < newest_date then newest_date = days_ago end
    end
  end

  local avg_lines = #files > 0 and math.floor(total_lines / #files) or 0
  local avg_size = #files > 0 and math.floor(total_size / #files) or 0

  Note("Log Statistics for " .. GetWorldName() .. ":")
  Note("  Logging: " .. (IsLogOpen() and "enabled" or "disabled"))
  Note("  Log files: " .. #files)
  Note("  Total size: " .. FormatSize(total_size) .. " (avg " .. FormatSize(avg_size) .. ")")
  Note("  Total lines: " .. total_lines .. " (avg " .. avg_lines .. ")")
  if oldest_date then
    Note("  Date range: " .. oldest_date .. " days to " .. (newest_date == 0 and "today" or newest_date .. " days ago"))
  end
  Note("  Directory: " .. GetLogDir())
end

function CmdToggle()
  if IsLogOpen() then
    EnableLogging(false)
    Note("Session logging disabled.")
  else
    EnableLogging(true)
    OpenDailyLog()
    Note("Session logging enabled.")
  end
end

local commands = {
  view = { func = CmdView },
  log = { func = CmdView },
  open = { func = CmdView },
  find = { func = CmdFind },
  stats = { func = CmdStats },
  toggle = { func = CmdToggle },
  help = { func = ShowHelp },
}

function LogManagerCLI(name, line, wildcards)
  local args = ParseArgs(wildcards[1] or "")
  local cmd = args[1] and args[1]:lower() or nil

  if not cmd then
    ShowHelp()
  elseif commands[cmd] then
    commands[cmd].func(args)
  else
    Note("Unknown command: " .. cmd .. ". Type 'lg help' for commands.")
  end
end

]]>
</script>

</muclient>
