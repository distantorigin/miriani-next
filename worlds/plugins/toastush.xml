<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, April 12, 2021, 3:48 PM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Toastush" generated by Plugin Wizard -->

<muclient>
<plugin
   name="MirianiNext"
   author="Miriani-Next Developers"
   id="843d2f53cb3685465bda7d4a"
   language="Lua"
   date_written="2021-04-12 15:47:28"
   requires="5.05"
   version="4.0"
   save_state="y"
   >

 <description trim="y">

    Welcome to Miriani-Next! Miriani-Next is a successor to the Toastush soundpack. Without the work by Erick Rosso and others, Miriani-Next wouldn't exist in its current form today. Thank you for trying it out and do let us know how you like it!

    ----------------------------------------

As of October 13, 2025, Toastush-NG is now a hard fork of the Toastush soundpack and is known as Miriani-Next. The plugin will continue to use the same ID and file name for compatibility, but otherwise you should expect functionality to break. Migrating from Toastush to Miriani-Next is not possible and requires re-entering your settings from scratch.
    
    To get started with configuring the soundpack, type 'conf'. To jump directly to a category, add the category name after the conf command like so: 'conf ship'. You can also press F1.
    To view the changelog, type 'whatsnew' or press F2.
      To toggle soundpack minimal mode type: `next:minimal or next:min.

    To fetch updates type: `update'
      - More help about using the updater can be found by typing `update --help'

    To view valid starmap filters type: `sm.help'
    To view valid scan filters type: `sc.help'
  
-------------------Key Bindings--------------

    - Audio:
    F9: Toggle global mute.
    Ctrl+F9: Toggle foreground sounds (sounds only when window has focus).
    F10: Cycle forward through audio groups.
    Shift+F10: Cycle backward through audio groups.
    F11: Decrease group volume.
    F12: Increase group volume.

- Output Buffers:
    alt+1 through alt+0 - read first through tenth latest message in buffer. pressing one of these keys twice within 0.5 seconds will copy the message to the clipboard, and 3 times will paste it into the command window.
        alt+Up / Down arrow: read next or previous message in buffer
            Alt + page up / down: move up or down 10 messages in buffer
                Alt + Home / end: Move up / down 2000 messages in buffer
                    Alt + Space: repeat current message
                        Alt + Shift + Space: Copy current message to clipboard
                            Alt + enter: open a URL in the current message if there is one, otherwise open world configuration
                                Alt+shift+1-0: jump to first through tenth buffer
    Alt + shift + ` (grave accent)( also works without shift): If you have some text typed in the command window, try to jump to a buffer starting with that text. Press the command with the window empty to return to where you were before the last jump. Effectively it lets you flip between two buffers this way.
    Alt + Backslash: If you have some text typed in the command window, searches toward the bottom of the current buffer for that text. Add shift to search toward the top of the buffer. If a match is found, focus jumps to that message.
    Alt+shift+enter; copy current buffer to a notepad
    Alt + shift + t: toggle timestamp announcements
    Alt + Q: Cycle through your quick list of buffers endlessly
    Alt + Shift + Q: Add/remove current buffer from quick list, or remove missing buffers after "not found" messages

    - Miscellaneous:
    ALT+SHIFT+U: Open last URL.
    CTRL+L: Initialize audio settings. (Helpful in the case of switching soundcards.)
    ALT+SHIFT+I: Read the info bar.
    Shift+escape: Reset sounds and various other trigger groups, good for fixing temporary oddities.

----------------------------------------
 
    ** Once in the game, tune a metaf frequency communicator to 7.07 for in game support. **
</description>
</plugin>


<!--  Get our standard constants -->

<!-- Constants are now loaded via require in the script section -->
<!--  Plugin help  -->

<!--  Timers  -->

<timers>

  <timer
   enabled="y"
   active_closed="y"
   hour="1"
   second="0"
   offset_second="0.00"
   script="detect_update_when_idle"
   send_to="14"
  >
  </timer>


  <timer
   enabled="y"
   name="heartbeat"
   active_closed="y"
   hour="0"
   second="1"
   offset_second="0.00"
   send_to="14"
  >
  <send>
   heartbeat = heartbeat + 1

   local roundtime_option = config:get_option("roundtime")
   if (roundtime_option.value == "yes") and
   (roundtime == 1) then
    mplay("misc/roundtime")
   end -- if round time


   if (roundtime &gt; 0) then
    roundtime = roundtime - 1
   end -- if

   if (stuntime ~= 0) then
    stuntime = stuntime - 1
   end -- if

   if (stuntime &lt; 0) then
    stuntime  = 0
   end -- if

   if (stuntime == 0)
   and (stunned == true) then
    stunned = false
    stop("environment", nil, 1, 0.5)
    if (environment) and (environment.line) then
      replicate_line(environment.line)
    end -- if
   end -- if

show_paralyzed(roundtime, stuntime)

    if (IsConnected()) then 
      if (heartbeat == ping_after_heartbeat) then
             Execute("#$#SOUNDPACK_PING")
      end -- if

   end -- if

   if (heartbeat &gt;= reset_heartbeat) then
       heartbeat = 0
   end -- if

</send>
  </timer>




</timers>


<!-- Triggers -->

<triggers>

  <trigger
 enabled="y"
   script="OnMSP"
   name="MSP"
   match="^(!!SOUND\(.+\))$"
   regexp="y"
   omit_from_output="y"
   send_to="14"
>
  </trigger>

  <trigger
  name="url_catcher"
   enabled="n"
   script="OnURL"
     match="((?:https?|ftp|telnet|rsync|mailto|gopher)://[[:graph:]]+[^&quot;])"
   regexp="y"
   send_to="12"
   keep_evaluating="y"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^\^(Creating|Deleting|Updating) Files: \d+%\.{3}$"
   regexp="y"
   omit_from_output="y"
   omit_from_log="y"
   send_to="14"
  >
  <send>notify("info", "%0", 1)</send>
  </trigger>
  <trigger
   enabled="n"
   name="MCP"
   match="^#\$#mcp(-\w+)?(?:-(\w+))? (\S+)(?: (.*))?$"
   regexp="y"
   send_to="12"
   omit_from_output="y"
   omit_from_log="y"
  >
  <send>
   MCP:handle_message("%0")
  </send>
  </trigger>


</triggers>

<aliases>

  <alias
   enabled="y"
   script="help"
   match="^next:help$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   script="info"
   match="^next:info$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^next:config(?:ure)?$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   match="^next:config(?:ure)? (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^conf(?:ig)?$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   match="^conf(?:ig)? (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>

  <alias
   enabled="y"
   match="^next:config(?:ure)? (\w+) (.+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="90"
  >
  <send>config_option_direct("%1", "%2")</send>
  </alias>

  <alias
   enabled="y"
   match="^conf(?:ig)? (\w+) (.+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="90"
  >
  <send>config_option_direct("%1", "%2")</send>
  </alias>

  <alias
   enabled="y"
   script="notepad_changelog"
   match="^(whatsnew|next:changes)$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Accessing the changelog...", 1)</send>
  </alias>

  <alias
   enabled="y"
   script="register"
   match="^next:register$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Sending Miriani-Next registration...", 1)</send>
  </alias>

  <alias
   enabled="y"
   match="^next:u(pdater)?-rel(oad)?$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>
   notify("info", "Reloading updater...")
   local ok, msg = ReloadPlugin(UPDATE_ID)
   if (ok == 0) then
     notify("info", "Updater reload complete.")
   else
     notify("info", "Updater reload failed.")
   end -- if

  </send>
  </alias>



  <alias
   enabled="y"
    name="minimal_mode_alias"
   script="toggle_minimal_mode"
   match="^next:min(?:imal)?$"
   regexp="y"
   send_to="12"
  >
  </alias>

  <alias
   enabled="y"
   name="fsounds_alias"
   match="^fsounds$"
   regexp="y"
   send_to="12"
  >
  <send>
    local current = config:get_option("foreground_sounds").value
    if current == "yes" then
      config:set_option("foreground_sounds", "no")
      Execute("tts_interrupt Sounds will play in background")
    else
      config:set_option("foreground_sounds", "yes")
      Execute("tts_interrupt Sounds only when window has focus")
    end
    mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
    config:save()
  </send>
  </alias>

  <alias
   enabled="y"
   match="^sim (.+)$"
   regexp="y"
   send_to="12"
  >
  <send>replicate_line("%1")</send>
  </alias>

</aliases>

<script>
<![CDATA[
dofile "lua/requirements.lua"
require("json")

scripts = "lua/miriani/scripts/"

require(scripts.."init")

MSP, GMCP = 90, 201 
timeout = 120
script = 12
registry = "Miriani-Next"
heartbeat = 0
reset_heartbeat = 60
ping_after_heartbeat = 30
roundtime, stuntime = 0, 0
stunned = false

EnableTrigger("url_catcher", false)

---------------------
-- Macros
Accelerator('F1', 'next:config')
Accelerator('F2', 'next:changes')
AcceleratorTo ("F10", 'forward_cycle_audio_groups()', script) -- cycle forward sound groups.
AcceleratorTo ("SHIFT+F10", 'previous_cycle_audio_groups()', script) -- cycle previous sound groups.

AcceleratorTo("F9", 'toggle_mute()', script)
AcceleratorTo("CTRL + F9", [[
  local current = config:get_option("foreground_sounds").value
  if current == "yes" then
    config:set_option("foreground_sounds", "no")
    Execute("tts_interrupt Sounds will play in background")
  else
    config:set_option("foreground_sounds", "yes")
    Execute("tts_interrupt Sounds only when window has focus")
  end
  mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
  config:save()
]], script)
AcceleratorTo("F11", 'decrease_attribute("volume")', script)
AcceleratorTo("F12", 'increase_attribute("volume")', script)
AcceleratorTo("ALT+SHIFT+U", 'open_url()', script)
AcceleratorTo("Esc", [[
  if dialog and dialog.is_active() then
    -- In a dialog: go back with "0"
    dialog.handle_input("0")
  elseif config:get_option("escape_abort").value == "yes" then
    -- Not in dialog: send @abort to game
    Send("@abort")
  else
    -- Select all and clear command text
    SetCommandSelection(1, #GetCommand())
    PasteCommand("")
  end
]], script)
AcceleratorTo("Tab", [[
  if config:get_option("tab_activates_notepad").value == "yes" then
    ActivateNotepad("output")
  end
]], script)
AcceleratorTo("ctrl+l", [[
  notify("info", "Reloading audio settings...")
  initialize_audio()
  notify("info", "Audio settings initialized.")]], script)

AcceleratorTo("ALT+SHIFT+I", [[
  local line = ""


  for k,v in pairs(infobar_t) do
    line = line..v.." - "
  end -- for
  notify("info", line, 1)

]], script)

AcceleratorTo("SHIFT+Esc", [[
  -- Reset status bar
  InfoClear()

  -- Stop all playing sounds
  stop()

  -- Reset scan state
  endScan()

  -- Say "Reset"
  Execute("tts_interrupt Reset")
]], script)







---------------------
-- script routines
-- Load constants
local constants = require(scripts.."constants")

-- Load constants into global scope
for k, v in pairs(constants) do
  _G[k] = v
end

local sp_options = require(scripts.."options")
local audio_options = require(scripts.."audio")

-- Load dialog system
local dialog_ok, dialog_module = pcall(require, scripts.."include/dialog")
if dialog_ok then
  dialog = dialog_module
else
  Note("Failed to load dialog system: " .. tostring(dialog_module))
  dialog = nil
end

function OnPluginInstall()
  math.randomseed(os.time())
  print("Welcome to Miriani-Next ", VERSION, ", a MUSHclient Miriani soundpack! For help see next:help.")
  print("Miriani-Next is in beta. Please review 'next:help' and tune a metafrequency communicator to frequency 7.07 for bugs and discussion.")
  print("Interested in contributing fixes or improvements? Please contact Noah Holland or ask more on the soundpacks' metafrequency channel.")

  initialize_audio()
    if (IsConnected() and GetVariable("logged_in") == "1") then
    EnableTrigger("url_catcher", true) -- Temporary fix before I rip it all out
    register()
    OnPluginGetFocus()
    if (GetVariable("last_environment_line")) then
  replicate_line(GetVariable("last_environment_line"))
end
  end -- if

  -- janitor code
  janitor()

  if (GetVariable("proxiani_enabled")) then
    EnableGroup("starmap", 0)
  end -- if

  -- check for minimal mode.
  if (GetVariable("minimal_mode") == "1") then
    toggle_minimal_groups(0)
  end -- if

end -- OnPluginInstall

function OnPluginSaveState()
  config:save()
end -- OnPluginSave

function OnPluginConnect()
  --register()
SetVariable("logged_in", 0)
end -- OnPluginConnect

function OnPluginDisconnect()
  DeleteVariable("proxiani_enabled")
  SetVariable("logged_in", 0)
  link = {}
  stop()
end -- OnPluginDisconnect

function OnPluginClose()
  -- Clean up all audio streams properly
  if sounds and sounds.cleanup_all_streams then
    sounds.cleanup_all_streams()
  else
    stop() -- fallback to basic stop
  end

  -- Clean up BASS audio system
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end
end -- OnPluginClose

function OnPluginSend(text)
  -- Prevent sending to server if dialog is active
  -- This catches input that didn't match any alias
  if dialog and dialog.is_active() then
    return false  -- Don't send to server
  end

  local s = text

  -- Convert smart quotes and other special characters to ASCII equivalents
  -- This prevents the MOO server from dropping non-ASCII characters
  s = s:gsub("\147", "\"")  -- Left double quote (U+0093)
  s = s:gsub("\148", "\"")  -- Right double quote (U+0094)
  s = s:gsub("\145", "'")   -- Left single quote (U+0091)
  s = s:gsub("\146", "'")   -- Right single quote (U+0092)
  s = s:gsub("\160", " ")   -- Non-breaking space (U+00A0)
  s = s:gsub("\150", "-")   -- En dash (U+0096)
  s = s:gsub("\151", "-")   -- Em dash (U+0097)
  s = s:gsub("\133", "...")  -- Ellipsis (U+0085)

  -- If text was modified, send the converted version instead
  if s ~= text then
    Send(s)
    return false  -- Don't send the original
  end

  return true  -- Send the original text
end -- OnPluginSend

function OnPluginLoseFocus()

  -- Reset focus flag.
  focusWindow = nil

  -- Call our focus handling function
  pause_all_sounds()

end -- OnPluginLoseFocus

function OnPluginGetFocus()

  -- Set focus flag.
  focusWindow = true

  -- Call our focus handling function
  resume_all_sounds()

end -- OnPluginGetFocus

function OnPluginTelnetRequest (type, data)
  if data == "WILL" then
    if type == GMCP then
      notify("info", "Enabled GMCP")
            return true
    elseif  type == MSP then
      notify("info", "Enabled MSP")
      return true
    end -- if
  end -- if
end -- function OnPluginTelnetRequest

function OnPluginTelnetSubnegotiation (type, data)
   if type == GMCP then
    gmcp_handler(data)
  end -- if
end -- function OnPluginTelnetSubnegotiation

function OnPluginBroadcast(msg, id, name, text)
  
  if id == "54846c23d8b15594e7eb4b8a" then
    if text=="output_boundary" then
      mplay("misc/boundary")
          end
  elseif id == "843d2f53cb3685465bda7d4c" then
    local message_type, data = text:match("([^|]+)|?(.*)")
    message_type = message_type or text
    
    if message_type == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = data:match("([^,]+),?([^,]*)")
      if group_name then
        -- Add to config.audio table for F10 cycling (preserve existing volume if group exists)
        if not config.audio[group_name] then
          config.audio[group_name] = {volume=50, pan=0}
        end

        -- Also add the config option for persistence (preserve existing value)
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          -- Use existing volume from config.audio if available, otherwise default to 50
          local existing_volume = config.audio[group_name] and config.audio[group_name].volume or 50
          config:add_option("volume", option_name, display_name, existing_volume, "number", "volume")
        end
      end
    elseif message_type == "unregister_audio_group" then
      -- Remove audio group (format: "groupname")
      if data and config.audio[data] then
        config.audio[data] = nil
      end
    elseif message_type == "play_sound" then
      -- Parse sound file and group from data (format: "filepath,group")
      local filepath, group = data:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    elseif message_type == "set_audio_volume" then
      -- Set audio group volume (format: "groupname,volume")
      local group_name, volume = data:match("([^,]+),([^,]+)")
      if group_name and volume then
        local vol_num = tonumber(volume)
        if vol_num and config.audio[group_name] then
          config:set_attribute(group_name, "volume", vol_num)
        end
      end
    elseif message_type == "get_audio_volume" then
      -- Get audio group volume and broadcast back (format: "groupname")
      local group_name = data
      if group_name and config.audio[group_name] then
        local volume = config:get_attribute(group_name, "volume") or 100
        BroadcastPlugin(999, "audio_volume_reply|" .. group_name .. "," .. volume)
      end
    end
  elseif id == UPDATE_ID then
    -- Updater plugin communication
    local info = json.decode.decode(text)

    for i, u in pairs(info.update) do
      local name = u[i]

      if type(name) == 'string' and string.find(name, "updater.xml") then
        notify("important", "The updater received an update. In order to apply changes, you must reload the plugin.\ntype: `toastush:updater-reload'")
        break
      end -- if
    end -- for

    if config:get_option("automatic_changelog").value == "yes" then
      notepad_changelog()
    end -- if
  else
    -- Other generic plugin communication handlers
    if msg == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = text:match("([^,]+),?([^,]*)")
      if group_name then
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          config:add_option("volume", option_name, display_name, 100, "number", "volume")
        end
      end
    elseif msg == "play_sound" then
      -- Parse sound file and group from text (format: "filepath,group")
      local filepath, group = text:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    end
  end
end -- OnPluginBroadcast

function OnPluginCommandEntered(text)
  last_command_time = os.time()

  -- Handle blank lines for dialog system (aliases don't catch them)
  if dialog and dialog.is_active() and text == "" then
    dialog.handle_input("")
    return
  end

  if (searchingScan) then
    searchingScan = false
    scan = nil
   classFilter = nil
  end -- if scan
end -- OnPluginCommandEnter

-- Combined with first OnPluginBroadcast function above


function gmcp_handler(data)

  -- Below follows a typical GMCP implementation.
  -- End users may wish to modify behavior.

  core, params = string.match(data, "([%a.]+)%s+(.*)")
  local info = json.decode(params)

  if core == "communication.channel" then
    Channel(info.channel, info.message, {"channels"})
  elseif core == "communication.say" then
    Channel("say", info.message, {"conversation"})
  elseif core == "communication.tell" then
    Channel("tell", info.message, {"tell"})
  end -- if
end -- gmcp_handler

function OnMSP(name, line, wc)

  local text = wc[1]
  local info = {
  file = string.match(text, "!![%u]+%(([%a%d%p]+).*%)"),
  type = string.match(text, "!![%u]+%(.*T=([%a%d]+).*%)"),
  volume = string.match(text, "!![%u]+%(.*V=([%d]+).*%)"),
  loop = string.match(text, "!![%u]+%(.*L=([%d]+).*%)"),
  continue = string.match(text, "!![%u]+%(.*C=([%d]+).*%)"),
  url = string.match(text, "!![%u]+%(.*U=([%a%d%p]+).*%)")
  }
  msp_handler(info)
end -- OnMSP

function msp_handler(info)

  -- Below follows a typical MSP implementation.
  -- End users may wish to modify behavior.

  play(info.file, info.type)
end -- msp_handler

function on_plugin_update()
  --  Externally called to indicate this plugin should be reloaded upon updates.
  return 1
end -- on_plugin_update

function janitor()

  -- Alert users of proxiani.
  local version = utils.split(VERSION, ".")
  if (tonumber(version[1]) < 3) then
    notify("info", [[

    Info: Beginning Toastush version 3.0.1 and onward, Toastush will now officially support popular Miriani proxy server, Proxiani.
    As a result, when the proxy server is detected, Toastush starmap commands will be disabled.
    Users can expect increased performance, shared features between clients, TLS connectivity and more!
    ]])

    notify("info",
    "See, "..PROXIANI.." for installation details.")

  end -- if


  -- Configure MUSHclient preferences:
  if (GetGlobalOption("F1macro") == 0)
  or (GetGlobalOption("ConfirmBeforeClosingMushclient") == 0)
  or (GetGlobalOption("ConfirmBeforeClosingWorld") == 1)
  or (GetGlobalOption("ConfirmBeforeSavingVariables") == 1) then
    db = sqlite3.open(GetInfo (82))  -- open preferences
    db:exec('UPDATE prefs SET value = 1 WHERE name = "F1macro"')
    db:exec('UPDATE prefs SET value = 1 WHERE name = "ConfirmBeforeClosingMushclient"')
    db:exec('UPDATE prefs SET value = 0 WHERE name = "ConfirmBeforeClosingWorld"')
    db:exec('UPDATE prefs SET value = 0 WHERE name = "ConfirmBeforeSavingVariables"')
    db:close()  -- close
    utils.reload_global_prefs ()
  end -- if

  -- plugins_updater no longer in use.

  local old_plugins = {
  ["fbd5b7cc1ef6acf827a3f4a1"] = "plugins_updater.xml",
  ["55e1d330539761f176fa0815"] = "indexer.xml", 
  } -- old_plugins

  table.foreach(old_plugins,
  function(id, name)
    if (IsPluginInstalled(id)) then
    print("plugin ", name, " is no longer in use. Unloading.")
    UnloadPlugin(id)
    end -- if
  end ) -- foreach

  -- need an index.
  local path = require("pl.path")
  if (not path.isfile(INDEX)) then
    notify("critical", string.format(
    "Warning: You appear to be missing the index file, '%s'. This file is necessary for updates. To generate the file now, type `index %s'", INDEX, INDEX))
  end -- if

  -- old version downloaded messy files.
  local dir = utils.readdir("*.ogg")
  local js = require("json.decode")
  local f = io.open("index-v5.manifest", "r")

  if (f and dir) then
    local t = f:read("*all")
    f:close()
    local info = js.decode(t)

    local paths = ""
    for path, _ in pairs(info) do
      paths = paths.." "..path
    end -- for

    for file, _ in pairs(dir) do
      if string.find(paths, file) then
        utils.shellexecute("cmd", "/C rmdir "..file, GetInfo(59), nil, 0)
      end -- if
    end -- for
  end -- if
end -- janitor

function detect_update_when_idle()

  if config:get_option("update_idle").value == "yes"
  and IsPluginInstalled(UPDATE_ID)
  and last_command_time ~= nil
  and (os.time() - last_command_time) >= IDLE_CUTOFF then
    Execute("update -q -f")
end -- if

end -- detect_update_when_idle

function toggle_minimal_mode(name, line, wc)
  local minimal_mode = (GetVariable("minimal_mode") == "1") and 1 or 0
  toggle_minimal_groups(minimal_mode)
  if (minimal_mode == 0) then


    SetVariable("minimal_mode", 1)
    notify("info", [[
    The soundpack is now in minimal mode.
    This mode disables the majority of triggers for a clean -- basic environment.
    Communications and miscellaneous gags will remain active.]])
  else

    DeleteVariable("minimal_mode")

    if (name == "minimal_mode_alias") then
      notify("info", "The soundpack is now in full -- regular mode.")
    end -- if
  end -- if
end -- minimal_mode

function toggle_minimal_groups(minimal_mode)
  for k,v in pairs(minimal_groups) do
    EnableGroup(v, minimal_mode)
  end -- for
  end -- toggle_minimal_groups

function initialize_audio()

  -- Clean up existing BASS instance if it exists
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end

  -- Initialize LUA Audio system
  Audio = require("miriani.lib.audio.audio")

  -- Initialize the audio system
  if Audio.BASS then
    BASS = Audio.BASS()

    -- Initialize BASS with retry logic for device switching
    if BASS then
      -- Flags: 1 (eight_bit) + 4 (three_d) = 5 (removed mono flag to get stereo by default)
      local init_result = BASS:Init(-1,44100,5)

      if init_result ~= 0 then
        -- Error codes: 4 = buffer_lost, 23 = device (illegal device number)
        -- 3 = driver (can't find free/valid driver)
        if init_result == 4 or init_result == 23 or init_result == 3 then
          Note("BASS device error (code " .. tostring(init_result) .. "), retrying with default device...")
          -- Free any partial initialization
          BASS:Free()
          -- Reinitialize BASS
          BASS = Audio.BASS()
          init_result = BASS:Init(-1,44100,5)
          if init_result ~= 0 then
            Note("BASS initialization retry failed with error: " .. tostring(init_result))
          else
            Note("BASS initialized successfully on retry")
          end
        else
          Note("BASS initialization failed with error: " .. tostring(init_result))
        end
      end
    end
  else
    Note("Audio.BASS not available")
  end

  local init_result = config:init(sp_options, audio_options)
  if init_result ~= 0 then
    print("Warning: Config initialization failed with code:", init_result)
    print("Continuing with basic initialization...")
  end

  if audio and audio.const and audio.const.device then
    local channels = audio.const.device.stereo
    audio:Init(nil, nil, channels)
  end

end -- initialize_audio


-- Load the new terminal-based config menu module
local config_menu_module = require(scripts.."config_menu")

function config_secondary_menu(option)
  -- Use new terminal-based menu system
  config_menu_module.show_group(option)
end -- config_secondary_menu


function config_main_menu()
  -- Use new terminal-based menu system
  config_menu_module.show_main()
end -- config_main_menu

function config_option_direct(group, option)
  -- Directly access an option by partial name or index
  config_menu_module.find_and_edit(group, option)
end -- config_option_direct

link = {}
infobar_t = {}


---------------------------------

function infobar(id, message, clear)
  id = id or 1

  if clear or message == "" then
    infobar_t[id] = nil
  end -- if


  local foreground = RGBColourToName(config:get_option("info_foreground_color").value)
  local background = RGBColourToName(config:get_option("info_background_color").value)
  local data = {}
  infobar_t[id] = message

  table.foreach(infobar_t,
  function (k, v)
    data[#(data) + 1] = v
  end ) -- foreach
 
  InfoClear()
  InfoColour(foreground)
  InfoBackground(background)

  Info(
  table.concat(data, " -- "))

end -- infobar

function latency(name, line, wildcard)
  local ms = tonumber(wildcard[1]) or 0
  infobar("lag", string.format ("Latency: %d MS", ms))
end -- latency

function show_paralyzed(roundtime, stuntime)
  local roundtime = roundtime or 0
  local stuntime = stuntime or 0
  local paralyzed = roundtime + stuntime
  local sec = (paralyzed == 1) and "second" or "seconds"
  local id = "paralyzed"
  if (paralyzed > 0) then
  infobar(id, string.format ("paralyzed: %d %s", paralyzed, sec))
  else
    infobar(id, "")
  end
end -- show_paralyzed

function help(name, line, wc)
  notify("info", string.format("%s", GetPluginInfo(GetPluginID(), 3)))
end-- help

function info(name, line, wc)
  local ID = GetPluginID()
  notify("info", string.format("%s  --  version %s  --  Scripting-language: %s  -- Script-time: %s seconds",
  GetPluginInfo(ID, 1),
  VERSION,
  GetPluginInfo(ID, 5),
  GetPluginInfo(ID, 24)))
end -- info

function channel(name, line, wc)

  -- Requires the channel history plugin.

  assert (IsPluginInstalled ("6000a4c6f0e71d31fecf523d"), "channel_history could not be found")

  if originating_from_camera(line) and name ~= "camera" then
  -- Don't duplicate camera messages in other buffers.
        return
  end -- camera
  -- add record table of channel arguments
   for k,v in ipairs(wc) do
    -- Handle metaf buffers
    if string.match(v, "^metaf ") then
      -- Check if separate buffers is enabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "yes" then
        -- Use frequency/label-specific buffer (no need to check metaf_buffer)
        Execute("history_add " .. v .. "=" .. line)
      else
        -- Use single metaf buffer if it's enabled
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
    elseif v == "metaf" then
      -- Regular metaf without frequency/label - only use if separate buffers is disabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "no" then
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
      -- If separate buffers is enabled, ignore plain "metaf" completely
    else
      -- Normal buffer handling
      buffer = config:get_option(string.format("%s_buffer", v))
      if buffer ~= nil and buffer.value == "yes" then
        Execute("history_add "..v.."="..line)
      end
    end -- if metaf
  end -- for loop
end -- channel

function OnURL(name, line, wc)
  channel("url", wc[1], {"url"})
  --Add the url to a recent url buffer.
  link =
  {
    url = wc[1],
    timestamp = os.clock()
 }
end -- OnURL

function open_url()
  if not link or not link.timestamp
  or os.clock() - link.timestamp > timeout then
    notify("info", "No url to open.")
  else
    local url = link.url
    notify("info", "Opening "..url, 1)
    play("audio/mouseClick.ogg")
    OpenBrowser(url)
  end -- if
end -- open_url

function mplay(file, group, interrupt, pan, loop, slide, sec)
  -- Miriani only play:
  local filepath

  if (config:get_option("alternate_audio").value == "yes") then
    local path = require("pl.path")
    local dir, fn = path.splitpath(file)
    if (path.isfile(config:get("SOUND_DIRECTORY")..ALTPATH..dir.."/"..fn..ALT_EXTENSION)) then
      filepath = ALTPATH..dir.."/"..fn..ALT_EXTENSION
    end -- if
  end -- if

  if (not filepath) then
    filepath = string.format(SOUNDPATH.."%s%s", file, EXTENSION)
  end -- if

  play(filepath, group, interrupt, pan, loop, slide, sec)
end -- mplay

function speech_interrupt(line)
  Execute("tts_interrupt "..line)
end -- speech_interrupt

function register()
  Send("#$#REGISTER_SOUNDPACK "..registry.." | "..VERSION.."\n")
  if not last_register_time or os.time() - last_register_time > 10 then
    mplay("misc/negotiate", "notification")
  end -- time
  last_register_time = os.time()
end -- register

function GetAudioVolume(group_name)
  -- Function for other plugins to call directly
  if group_name and config.audio[group_name] then
    return tostring(config:get_attribute(group_name, "volume") or 100)
  end
  return ""
end -- GetAudioVolume

function set_environment(name, line, wc)
  environment = {}

  environment.name = name
  environment.line = line
    SetVariable("last_environment_line", line)

  -- iterate through a table of flags
  -- and set all to true.
  -- split any deliminated tags and make them into their own truth value.

  for _, flag in ipairs(wc) do

    local names = utils.split(flag, " ")

    table.foreach(names,
    function(_, value)
      environment[string.lower(value)] = true
    end ) -- foreach
  end -- for

  -- Debug output is enabled
  if config:get_option("debug_mode").value == "yes" then
    local flags = {}
    for k, v in pairs(environment) do
      if k ~= "name" and k ~= "line" and v == true then
        table.insert(flags, k)
      end
    end
    if #flags > 0 then
      notify("info", "Environment [" .. name .. "]: " .. table.concat(flags, ", "))
    end
  end

  -- ambiance
  ambiance(wc[#wc])
end -- set_environment

function playstep()

  if (not foundstep) or (not environment) or (not room) then
    return 0
  end -- if

  foundstep = false

  -- Stop here if aquatic
  if environment.marine
  or string.find (room, "aquatic") then
    mplay ("steps/swim")
    return 1
  end -- if

  local file
  local function set_type(t, type, check)
    local ok
    for _, keyword in ipairs(t) do
      if string.find(string.lower(check), keyword) then
        file = type
        ok = 1
        break
      end -- if
    end -- for

    return ok
  end -- check_type

  local deserts = {"desert", "beach", "shore", "sand", "wasteland"}
  local forests = {"forest", "woods", "field", "grass", "jungle", "glade", "dale", "farm", "glen"}
  local muddy = {"mud", "swamp", "marsh"}
  local flying = {"fly", "float", "hover"}
  local ducts = {"duct", "crawlspace"}
  local skating = {"skate", "rollerblade"}


  if set_type(deserts, "desert", room) == 1
  or set_type(forests, "forest", room) == 1
  or set_type(muddy, "mud", room) == 1
  or set_type(ducts, "duct", room) == 1
  or set_type(flying, "fly", footstep) == 1
  or set_type(skating, "skate", footstep) == 1 then
    mplay("steps/"..file)
    return 1
  end -- if

  -- play sounds if environment is starship.
  if environment.name == "starship" then
    mplay ("steps/starship")
    return 1
  end -- if

  -- play sound if environment is station 
  if environment.name == "station" then
    mplay ("steps/station")
    return 1
  end -- if

  if environment.indoors then
    mplay("steps/planet/indoors")
  else
    mplay("steps/planet/outdoors")
  end -- if

  return 1
end -- playstep

-- Socials that require targeting check (only play when you're the target)
local targeted_socials = {
  ["poke"] = true,
  ["nudge"] = true
}

-- Social aliases - map different social actions to existing sound files
local social_aliases = {
  ["slug"] = "punch",
  ["sock"] = "punch",
  ["hit"] = "punch"
}

function playsocial(name, line, wc)
  -- Try to match social to file
  -- Game shortens the social text depending on what user typed.
  local social_action = wc[1]
  local gender = wc[2]

  -- Randomly assign gender if nonbinary.
  if gender == "nonbinary" then
    local genders = {"male","female"}
    gender = genders[math.random(2)]
  end

  -- Check if this social requires targeting validation
  if targeted_socials[social_action] then
    -- Check if we have a recent message that matches this social
    if pending_targeted_message and (os.time() - pending_targeted_message.timestamp <= 2) and pending_targeted_message.action == social_action then
      -- Play the targeted social
      local sound_action = social_aliases[social_action] or social_action
      local socialtable = utils.readdir(config:get("SOUND_DIRECTORY")..SOUNDPATH.."social/"..gender.."/"..sound_action.."*"..EXTENSION)

      -- If no files found with specified gender, try neuter as fallback
      if type(socialtable) ~= 'table' and gender ~= "neuter" then
        gender = "neuter"
        socialtable = utils.readdir(config:get("SOUND_DIRECTORY")..SOUNDPATH.."social/"..gender.."/"..sound_action.."*"..EXTENSION)
      end

      if type(socialtable) == 'table' then
        local social = string.match(string.gsub(next(socialtable), "%d+", ""), "("..string.lower(sound_action).."[%w%W]+)")
        social = string.gsub(social, EXTENSION, "")
        mplay("social/"..gender.."/"..social, "socials")
      end

      -- Clear the pending message
      pending_targeted_message = nil
    end
    return 0 -- Don't play normal social
  end

  -- Play normal socials immediately
  -- Check if we need to use an alias
  local sound_action = social_aliases[social_action] or social_action
  local socialtable = utils.readdir(config:get("SOUND_DIRECTORY")..SOUNDPATH.."social/"..gender.."/"..sound_action.."*"..EXTENSION)
  -- check that table exists
  if type(socialtable) ~= 'table' then
    if gender ~= "neuter" then
      gender = "neuter"
      -- Recursive call with neuter gender
      local new_wc = {social_action, gender}
      return playsocial(name, line, new_wc)
    else
      return 0
    end -- recursive
  end -- if social exists

  local social = string.match (
  string.gsub (next(socialtable), "%d+", ""), "("..string.lower(sound_action).."[%w%W]+)")
  social = string.gsub (social, EXTENSION, "")

  mplay ("social/"..gender.."/"..social, "socials")
end -- playsocial

function ambiance(roomtype)

  if (not environment)
  or not focusWindow
  or (cameraFeed)
  or (stunned)
  or config:get_option("background_ambiance").value == "no" then
    return 0
  end -- if

  local file = nil
  local fade = 0.8
  local names = utils.split(roomtype, " ")
  local rname = string.lower(names[#names])  

  if (environment.name == "starship") then

    local r = rooms.starship[rname]
    if environment.unpowered then
      file = "starship_unpowered"
    elseif r then
      file = r
    end -- if

  elseif (environment.name == "room") then

    if (environment.outdoors) then
      -- probably a roid.
      file = "asteroid"
    elseif environment.lift then
      file = "lift"
    elseif environment.ITPN then
      file = "ITPN"
    end -- if

  elseif environment.indoors and environment.lift then
    file = "lift"
  elseif (environment.name == "planet") then
    if environment.marine then
      file = "marine"
    elseif environment.rocky and environment.outdoors then
      file = "rocky"
    elseif environment.river then
      file = environment.outdoors and "lake" or "indoorRiver"
    elseif (environment.digsite) and (environment.indoors) and (environment.safe) then
      file = "cave"
    elseif environment.terrestrial and environment.outdoors then
      file = "terrestrial"
    elseif environment.transterrestrial and environment.outdoors then
      file = "transterrestrial"
    elseif environment.ice and environment.outdoors then
      file = "ice"
    end -- if

  elseif (environment.name == "vehicle") then
    if environment.unpowered then
      file = "starship_unpowered"
    else
      file = "vehicle"
    end -- if
  end -- if

  if (not file)
  and (rooms[environment.name]) then
    file = rooms[environment.name][rname]
  end -- if

  if file ~= nil then
    if file ~= ambianceFile then
      ambianceFile = file -- avoid repeat loops.
      mplay("ambiance/"..file, "ambiance", 1, nil, 1, 1, fade) 
    end -- if
  else
    stop("ambiance", nil, 1, fade) -- fade out previous
    ambianceFile = nil
  end -- if



end -- playambiance

function gagline(name, line, wc)
  if config:get_option("spam").value == "no" then
    print(line)
  else
  return 1
  end -- if

end -- gagline

function notepad_changelog(name, line, wc)

  local f = io.open(scripts.."changelog.txt", "r")
  if (f) then
    local text = f:read("*all")
    f:close()
    AppendToNotepad("Changelog", string.gsub(text, "\n", "\r\n"), "\r\n")
    ActivateNotepad("changelog")
  end -- if
end -- notepad_changelog

function replicate_line(line)
  Simulate("\r\n"..line.."\r\n")
end -- replicate_line

function print_hyperlink(l, text, hint, browser)
  browser = browser or 1
  local foreground = RGBColourToName(config:get_option("hyperlink_foreground_color").value)
  local background = RGBColourToName(config:get_option("hyperlink_background_color").value)

  Hyperlink(l, text, hint, foreground, background, browser)
  Note()

end -- print_hyperlink

function print_color(...)
  -- print lines with predefined colors:
  local content = {}

  for k,v in pairs({...}) do

    local group = v[2] or "default"
    content[#(content)+1] = RGBColourToName(
  config:get_option(group.."_color").value or 0)

    content[#(content)+1] = RGBColourToName(
    config:get_option("background_color").value)
    content[#(content)+1] = v[1]
  end -- for
  ColourNote(unpack(content))
end -- print_color

function originating_from_camera(line)
  if GetVariable("last_camera_line") and GetVariable("last_camera_line") == line then
  DeleteVariable("last_camera_line")
  return true
  end -- GetVariable
  return false
  end -- originating_from_camera
]]>
</script>


</muclient>
