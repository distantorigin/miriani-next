<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, April 12, 2021, 3:48 PM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Toastush" generated by Plugin Wizard -->

<muclient>
<plugin
   name="MirianiNext"
   author="Miriani-Next Developers"
   id="843d2f53cb3685465bda7d4a"
   language="Lua"
   date_written="2021-04-12 15:47:28"
   requires="5.05"
   version="4.0"
   save_state="y"
   >

 <description trim="y">

    Welcome to Miriani-Next! Miriani-Next is a successor to the Toastush soundpack. Without the work by Erick Rosso and others, Miriani-Next wouldn't exist in its current form today. Thank you for trying it out and do let us know how you like it!

    ----------------------------------------

As of October 13, 2025, Toastush-NG is now a hard fork of the Toastush soundpack and is known as Miriani-Next. The plugin will continue to use the same ID and file name for compatibility, but otherwise you should expect functionality to break. Migrating from Toastush to Miriani-Next is not possible and requires re-entering your settings from scratch.
    
    To get started with configuring the soundpack, type 'conf'. To jump directly to a category, add the category name after the conf command like so: 'conf ship'. You can also press F1.
    To view the changelog, type 'whatsnew' or press F2.
      To toggle soundpack minimal mode type: `next:minimal or next:min.

    To fetch updates type: `update'
      - More help about using the updater can be found by typing `update help'

    To view valid starmap filters type: `sm.help'
    To view valid scan filters type: `sc.help'
  
-------------------Key Bindings--------------

    - Audio:
    F9: Toggle global mute.
    Ctrl+F9: Toggle foreground sounds (sounds only when window has focus).
    F10: Cycle forward through audio groups.
    Shift+F10: Cycle backward through audio groups.
    F11: Decrease group volume.
    F12: Increase group volume.

- Output Buffers:
    alt+1 through alt+0 - read first through tenth latest message in buffer. pressing one of these keys twice within 0.5 seconds will copy the message to the clipboard, and 3 times will paste it into the command window.
        alt+Up / Down arrow: read next or previous message in buffer
            Alt + page up / down: move up or down 10 messages in buffer
                Alt + Home / end: Move up / down 2000 messages in buffer
                    Alt + Space: repeat current message
                        Alt + Shift + Space: Copy current message to clipboard
                            Alt + enter: open a URL in the current message if there is one, otherwise open world configuration
                                Alt+shift+1-0: jump to first through tenth buffer
    Alt + shift + ` (grave accent)( also works without shift): If you have some text typed in the command window, try to jump to a buffer starting with that text. Press the command with the window empty to return to where you were before the last jump. Effectively it lets you flip between two buffers this way.
    Alt + Backslash: If you have some text typed in the command window, searches toward the bottom of the current buffer for that text. Add shift to search toward the top of the buffer. If a match is found, focus jumps to that message.
    Alt+shift+enter; copy current buffer to a notepad
    Alt + shift + t: toggle timestamp announcements
    Alt + Q: Cycle through your quick list of buffers endlessly
    Alt + Shift + Q: Add/remove current buffer from quick list, or remove missing buffers after "not found" messages

    - Miscellaneous:
    ALT+SHIFT+U: Open last URL.
    CTRL+L: Initialize audio settings. (Helpful in the case of switching soundcards.)
    ALT+SHIFT+I: Read the info bar.
    Shift+escape: Reset sounds and various other trigger groups, good for fixing temporary oddities.

----------------------------------------
 
    ** Once in the game, tune a metaf frequency communicator to 7.07 for in game support. **
</description>
</plugin>


<!--  Get our standard constants -->

<!-- Constants are now loaded via require in the script section -->
<!--  Plugin help  -->

<!--  Timers  -->

<timers>

  <timer
   enabled="y"
   active_closed="y"
   hour="1"
   second="0"
   offset_second="0.00"
   script="detect_update_when_idle"
   send_to="14"
  >
  </timer>


  <timer
   enabled="y"
   name="heartbeat"
   active_closed="y"
   hour="0"
   second="1"
   offset_second="0.00"
   send_to="14"
  >
  <send>
   heartbeat = heartbeat + 1

   local roundtime_option = config:get_option("roundtime")
   if (roundtime_option.value == "yes") and
   (roundtime == 1) then
    mplay("misc/roundtime")
   end -- if round time


   if (roundtime &gt; 0) then
    roundtime = roundtime - 1
   end -- if

   if (stuntime ~= 0) then
    stuntime = stuntime - 1
   end -- if

   if (stuntime &lt; 0) then
    stuntime  = 0
   end -- if

   if (stuntime == 0)
   and (stunned == true) then
    stunned = false
    stop("environment", nil, 1, 0.5)
    updateAmbiance()
   end -- if

show_paralyzed(roundtime, stuntime)

    if (IsConnected()) then 
      if (heartbeat == ping_after_heartbeat) then
             SendNoEcho("#$#SOUNDPACK_PING")
      end -- if

   end -- if

   if (heartbeat &gt;= reset_heartbeat) then
       heartbeat = 0
   end -- if

</send>
  </timer>




</timers>


<!-- Triggers -->

<triggers>

  <trigger
 enabled="y"
   script="OnMSP"
   name="MSP"
   match="^(!!SOUND\(.+\))$"
   regexp="y"
   omit_from_output="y"
   send_to="14"
>
  </trigger>

  <trigger
   enabled="n"
   name="MCP"
   match="^#\$#mcp(-\w+)?(?:-(\w+))? (\S+)(?: (.*))?$"
   regexp="y"
   send_to="12"
   omit_from_output="y"
   omit_from_log="y"
  >
  <send>
   MCP:handle_message("%0")
  </send>
  </trigger>

</triggers>

<aliases>

  <alias
   enabled="y"
   script="help"
   match="^next:help$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   script="info"
   match="^next:info$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^next:config(?:ure)?$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   match="^next:config(?:ure)? (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^conf$"
   ignore_case="y"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   match="^conf (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>

  <alias
   enabled="y"
   match="^next:config(?:ure)? (\w+) (.+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="90"
  >
  <send>config_option_direct("%1", "%2")</send>
  </alias>

  <alias
   enabled="y"
   match="^conf (\w+) (.+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
   sequence="90"
  >
  <send>config_option_direct("%1", "%2")</send>
  </alias>

  <alias
   enabled="y"
   script="notepad_changelog"
   match="^(whatsnew|next:changes)$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Accessing the changelog...", 1)</send>
  </alias>

  <alias
   enabled="y"
   script="register"
   match="^next:register$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Sending Miriani-Next registration...", 1)</send>
  </alias>

  <alias
   enabled="y"
    name="minimal_mode_alias"
   script="toggle_minimal_mode"
   match="^next:min(?:imal)?$"
   regexp="y"
   send_to="12"
  >
  </alias>

  <alias
   enabled="y"
   name="fsounds_alias"
   match="^fsounds$"
   regexp="y"
   send_to="12"
  >
  <send>
    local current = config:get_option("foreground_sounds").value
    if current == "yes" then
      config:set_option("foreground_sounds", "no")
      Execute("tts_interrupt Sounds will play in background")
    else
      config:set_option("foreground_sounds", "yes")
      Execute("tts_interrupt Sounds only when window has focus")
    end
    mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
    config:save()
  </send>
  </alias>

  <alias
   enabled="y"
   name="dnd_alias"
   match="^dnd(?: (on|off))?$"
   regexp="y"
   send_to="12"
  >
  <send>
    if "%1" == "on" then
      if not config:is_dnd() then
        toggle_dnd()
      else
        Execute("tts_interrupt Do Not Disturb already enabled")
        notify("info", "Do Not Disturb already enabled")
      end
    elseif "%1" == "off" then
      if config:is_dnd() then
        toggle_dnd()
      else
        Execute("tts_interrupt Do Not Disturb already disabled")
        notify("info", "Do Not Disturb already disabled")
      end
    else
      toggle_dnd()
    end
  </send>
  </alias>

  <alias
   enabled="y"
   match="^sim (.+)$"
   regexp="y"
   send_to="12"
  >
  <send>replicate_line("%1")</send>
  </alias>

  <alias
   enabled="y"
   name="alt_space_handler"
   match="^altspace$"
   regexp="y"
   send_to="12"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
  >
  <send>handle_alt_space()</send>
  </alias>

  <alias
   enabled="y"
   name="MirianiSoundPlay"
   match="^MirianiSoundPlay (.+)$"
   regexp="y"
   send_to="12"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
  >
  <send>
    -- Parse arguments: file [group] [interrupt] [pan] [loop] [slide] [sec] [frequency]
    local args_str = "%1"
    local args = {}

    -- Split by comma or space, handling quoted strings
    for arg in args_str:gmatch("[^,]+") do
      arg = arg:match("^%s*(.-)%s*$") -- trim whitespace
      if arg ~= "" and arg ~= "nil" then
        table.insert(args, arg)
      else
        table.insert(args, nil)
      end
    end

    -- Convert numeric strings to numbers for appropriate parameters
    local file = args[1]
    local group = args[2]
    local interrupt = args[3] and tonumber(args[3])
    local pan = args[4] and tonumber(args[4])
    local loop = args[5] and tonumber(args[5])
    local slide = args[6] and tonumber(args[6])
    local sec = args[7] and tonumber(args[7])
    local frequency = args[8] and (args[8] == "true" or tonumber(args[8]) == 1)

    -- Call mplay with parsed arguments
    if file then
      mplay(file, group, interrupt, pan, loop, slide, sec, frequency)
    end
  </send>
  </alias>

  <alias
   enabled="y"
   name="VolumeControl"
   match="^vol(?:ume)?\s+(up|down|next|prev)$"
   regexp="y"
   send_to="12"
   omit_from_log="y"
   omit_from_output="y"
  >
  <send>
    local action = string.lower("%1")
    if action == "up" then
      increase_attribute("volume")
    elseif action == "down" then
      decrease_attribute("volume")
    elseif action == "next" then
      forward_cycle_audio_groups()
    elseif action == "prev" then
      previous_cycle_audio_groups()
    end
  </send>
  </alias>

</aliases>

<script>
<![CDATA[
require("json")
done = false
scripts = "lua/miriani/scripts/"

function OnPluginListChanged()
 if not IsPluginInstalled("6773a4c6f0e71d32feac526e") and not done then
  -- Make sure current users have the requirements plugin
  done = true
  dofile("lua/requirements.lua")
  end
 end

require(scripts.."init")

MSP, GMCP = 90, 201 
timeout = 120
script = 12
registry = "Miriani-Next"
heartbeat = 0
reset_heartbeat = 60
ping_after_heartbeat = 30
roundtime, stuntime = 0, 0
stunned = false
has_alternate_audio = false

---------------------
-- Macros
Accelerator('F1', 'next:config')
Accelerator('F2', 'next:changes')
AcceleratorTo ("F10", 'forward_cycle_audio_groups()', script) -- cycle forward sound groups.
AcceleratorTo ("SHIFT+F10", 'previous_cycle_audio_groups()', script) -- cycle previous sound groups.

AcceleratorTo("F9", 'toggle_mute()', script)
AcceleratorTo("CTRL + F9", [[
  local current = config:get_option("foreground_sounds").value
  if current == "yes" then
    config:set_option("foreground_sounds", "no")
    Execute("tts_interrupt Sounds will play in background")
  else
    config:set_option("foreground_sounds", "yes")
    Execute("tts_interrupt Sounds only when window has focus")
  end
  mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
  config:save()
]], script)
AcceleratorTo("CTRL+D", 'toggle_dnd()', script)
AcceleratorTo("F11", 'decrease_attribute("volume")', script)
AcceleratorTo("F12", 'increase_attribute("volume")', script)
AcceleratorTo("ALT+SHIFT+U", 'open_url()', script)
AcceleratorTo ("CTRL+SHIFT+A", 'Execute("tts_interrupt The AutoSay keyboard shortcut has been disabled. You can enable AutoSay from the game menu.")', script)
AcceleratorTo("Esc", [[
  if dialog and dialog.is_active() then
    -- In a dialog: go back with "0"
    dialog.handle_input("0")
  elseif config:get_option("escape_abort").value == "yes" then
    -- Not in dialog: send @abort to game
    Send("@abort")
  else
    -- Select all and clear command text
    SetCommandSelection(1, #GetCommand())
    PasteCommand("")
  end
]], script)
-- Tab accelerators are set up by update_tab_accelerators() function
AcceleratorTo("ctrl+l", [[
  notify("info", "Reloading audio settings...")
  initialize_audio()
  notify("info", "Audio settings initialized.")]], script)

AcceleratorTo("ALT+SHIFT+I", [[
  local line = ""


  for k,v in pairs(infobar_t) do
    line = line..v.." - "
  end -- for
  notify("info", line, 1)

]], script)

AcceleratorTo("SHIFT+Esc", [[
  -- Reset status bar
  InfoClear()

  -- Stop all playing sounds
  stop()

  -- Reset scan state
  endScan()

  -- Say "Reset"
  Execute("tts_interrupt Reset")
]], script)

Accelerator("alt+space", "altspace")
Accelerator("CTRL+e", "checkrepairtimer")

AcceleratorTo("CTRL+SHIFT+H", [[
  if lastScannedHullDamage then
    Execute("tts_interrupt Hull: " .. lastScannedHullDamage)
  else
    Execute("tts_interrupt No hull damage data")
  end
]], script)

AcceleratorTo("CTRL+SHIFT+D", [[
  if lastScannedComponentDamage then
    Execute("tts_interrupt Components: " .. lastScannedComponentDamage)
  else
    Execute("tts_interrupt No component damage data")
  end
]], script)







---------------------
-- Tab key functions
---------------------

-- Function to handle tab key press for accessible output
function HandleTabForOutput()
  -- Check if this is the first time using tab for output
  local first_time = GetVariable("tab_output_first_time")

  if first_time == nil or first_time == "1" then
    SetVariable("tab_output_first_time", "0")

    -- Ask if they want to enable this feature
    local result = utils.umsgbox(
      "ðŸ‘‹ It looks like you pressed Tab.\n\n" ..
      "Would you like to enable Accessible Output Mode? This will make Tab and Shift+Tab switch focus to the accessible output window, making it easier to review game text with your screen reader.\n\n" ..
      "Tab completion will be moved to Ctrl+Space instead.\n\n" ..
      "You can change this anytime in the config menu (conf). This message will only appear once.",
      "Enable Accessible Output Mode?",
      "yesno",
      "?",
      1
    )

    if result == "yes" then
      -- Enable the option
      config:set_option("tab_activates_notepad", "yes")
      config:save()
      update_tab_accelerators()
      ActivateAccessibleOutput()
    else
      -- They said no, disable the option
      config:set_option("tab_activates_notepad", "no")
      config:save()
      update_tab_accelerators()
      -- Do default tab completion instead
      DoCommand("KeysTab")
    end
  else
    -- Not first time, just activate
    ActivateAccessibleOutput()
  end
end

-- Function to update tab accelerators based on option state
function update_tab_accelerators()
  -- Make sure config is available
  if not config then
    Note("Warning: config not initialized yet, tab accelerators not set")
    return
  end
  if not GetVariable("tab_output_first_time") then
    config:set_option("tab_activates_notepad", "yes")
      end
  local option = config:get_option("tab_activates_notepad")
  if not option then
    Note("Warning: tab_activates_notepad option not found")
    return
  end

  local option_value = option.value

  if option_value == "yes" then
    -- Tab activates accessible output
    world.AcceleratorTo("Tab", "HandleTabForOutput()", sendto.script)
    world.AcceleratorTo("Shift+Tab", "HandleTabForOutput()", sendto.script)
    -- Ctrl+Space does tab completion
    world.AcceleratorTo("Ctrl+Space", "DoCommand('KeysTab')", sendto.script)
  else
    -- Tab does default tab completion
    world.AcceleratorTo("Tab", "DoCommand('KeysTab')", sendto.script)
    -- Clear Shift+Tab
    world.AcceleratorTo("Tab", "DoCommand('KeysShiftTab')", sendto.script)
    -- Clear Ctrl+Space
    world.Accelerator("Ctrl+Space", "")
  end
end

---------------------
-- script routines
-- Load constants
local constants = require(scripts.."constants")

-- Load constants into global scope
for k, v in pairs(constants) do
  _G[k] = v
end

local sp_options = require(scripts.."options")
local audio_options = require(scripts.."audio")

-- Load dialog system
local dialog_ok, dialog_module = pcall(require, scripts.."include/dialog")
if dialog_ok then
  dialog = dialog_module
else
  Note("Failed to load dialog system: " .. tostring(dialog_module))
  dialog = nil
end

function OnPluginInstall()
  math.randomseed(os.time())
  print("Welcome to Miriani-Next ", VERSION, ", a MUSHclient Miriani soundpack! For help see next:help.")
  print("Miriani-Next is in beta. Please review 'next:help' and tune a metafrequency communicator to frequency 7.07 for bugs and discussion.")
  print("If you're interested in watching the development process from afar, metafrequency 338.7 is the channel. This is public because we want to encourage discussion and new people to work on the soundpack, but if we get an influx of questions or nonsense we will change it and not provide the new frequency.")
  print("Frequency 7.07 should still be used for install questions, etc, and most other things. Only tune to channel 338.7 if you are interested in LUA code, triggers, MUSHClient work etc.")


  initialize_audio()

  -- Reset Do Not Disturb mode on plugin reload
  config:set_dnd(false)

  -- Reset mute and speech on plugin reload
  config.master_mute = false

  -- Check if alternate audio folder exists
  local path = require("pl.path")
  local alt_path = (config:get("SOUND_DIRECTORY") .. ALTPATH):gsub("/$", "")
  has_alternate_audio = path.isdir(alt_path)
  if has_alternate_audio then
    print("Alternate audio folder detected. Alternate sounds will be used when available.")
  end

    if (IsConnected() and GetVariable("logged_in") == "1") then
    register()
    OnPluginGetFocus()
    if (GetVariable("last_environment_line")) then
      replicate_line(GetVariable("last_environment_line"))
    end
    -- Restore room for playstep (walk style sounds)
    if (GetVariable("last_room")) then
      room = GetVariable("last_room")
    end
    -- Restore ambiance directly from saved state
    DoAfterSpecial(0.5, "restoreAmbiance()", sendto.script)
  end -- if

  -- janitor code
  janitor()

if config:get_option("reset_counters_on_startup").value == "yes" then
    reset_counters(1)
  end

  if (GetVariable("proxiani_enabled")) then
    EnableGroup("starmap", 0)
    create_proxiani_bypass_aliases()
  end -- if

  -- check for minimal mode.
  if (GetVariable("minimal_mode") == "1") then
    toggle_minimal_groups(0)
  end -- if

  -- Set up tab accelerators based on current option
  update_tab_accelerators()

  -- Ctrl+Shift+V pastes clipboard with linebreaks converted to spaces
  world.AcceleratorTo("Ctrl+Shift+V", "PasteAsOneLine()", sendto.script)

end -- OnPluginInstall

function PasteAsOneLine()
  local text = GetClipboard()
  if text then
    text = text:gsub("\r\n", " "):gsub("\r", " "):gsub("\n", " ")
    PasteCommand(text)
  end
end

function OnPluginSaveState()
  config:save()
end -- OnPluginSave

function OnPluginConnect()
  --register()
SetVariable("logged_in", 0)
end -- OnPluginConnect

function OnPluginDisconnect()
  if mcp then mcp:cleanup() end
  DeleteVariable("proxiani_enabled")
  SetVariable("logged_in", 0)
  link = {}
  stop()
end -- OnPluginDisconnect

function OnPluginClose()
  -- Clean up all audio streams properly
  if sounds and sounds.cleanup_all_streams then
    sounds.cleanup_all_streams()
  else
    stop() -- fallback to basic stop
  end

  -- Clean up BASS audio system
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end
end -- OnPluginClose

function OnPluginSend(text)
  -- Prevent sending to server if dialog is active
  -- This catches input that didn't match any alias
  if dialog and dialog.is_active() then
    return false  -- Don't send to server
  end

  local s = text

  -- Convert smart quotes and other special characters to ASCII equivalents
  -- This prevents the MOO server from dropping non-ASCII characters
  s = s:gsub("\147", "\"")  -- Left double quote (U+0093)
  s = s:gsub("\148", "\"")  -- Right double quote (U+0094)
  s = s:gsub("\145", "'")   -- Left single quote (U+0091)
  s = s:gsub("\146", "'")   -- Right single quote (U+0092)
  s = s:gsub("\160", " ")   -- Non-breaking space (U+00A0)
  s = s:gsub("\150", "-")   -- En dash (U+0096)
  s = s:gsub("\151", "-")   -- Em dash (U+0097)
  s = s:gsub("\133", "...")  -- Ellipsis (U+0085)

  -- If text was modified, send the converted version instead
  if s ~= text then
    Send(s)
    return false  -- Don't send the original
  end

  return true  -- Send the original text
end -- OnPluginSend

function create_proxiani_bypass_aliases()
  -- First, clear any existing bypass aliases
  clear_proxiani_bypass_aliases()

  -- Only create if Proxiani is enabled
  if not GetVariable("proxiani_enabled") then return end

  local bypass_list = config:get_option("proxiani_bypass_commands").value or ""
  if bypass_list == "" then return end

  for cmd in bypass_list:gmatch("([^,]+)") do
    cmd = cmd:match("^%s*(.-)%s*$") -- trim whitespace
    if cmd ~= "" then
      local alias_name = "px_bypass_" .. cmd:lower()
      -- Pattern: ^cmd\b(.*)$ matches command at word boundary, captures rest (including space)
      -- ResponseText: "px pass cmd%1" sends the bypass with any arguments
      local pattern = "^" .. cmd .. "\\b(.*)$"
      local response = "px pass " .. cmd .. "%1"
      -- Flags: eEnabled(1) + eIgnoreAliasCase(32) + eAliasRegularExpression(128) + eTemporary(16384)
      local flags = 16545
      AddAlias(alias_name, pattern, response, flags, "")
    end
  end
end -- create_proxiani_bypass_aliases

function clear_proxiani_bypass_aliases()
  -- Delete ALL px_bypass_* aliases regardless of current config
  -- This handles cases where user removed commands from the list
  local alias_list = GetAliasList()
  if alias_list then
    for _, alias_name in ipairs(alias_list) do
      if alias_name:match("^px_bypass_") then
        DeleteAlias(alias_name)
      end
    end
  end
end -- clear_proxiani_bypass_aliases

function OnPluginLoseFocus()

  -- Reset focus flag.
  focusWindow = nil

  -- Call our focus handling function
  pause_all_sounds()

  -- Autosilence engines if option is enabled
  if config and config:get_option("autosilence_on_focus_loss").value == "yes" then
    force_engine_silence()
  end

end -- OnPluginLoseFocus

function OnPluginGetFocus()

  -- Set focus flag.
  focusWindow = true

  -- Call our focus handling function
  resume_all_sounds()

end -- OnPluginGetFocus

function OnPluginTelnetRequest (type, data)
  if data == "WILL" then
    if type == GMCP then
      notify("info", "Enabled GMCP")
            return true
    elseif  type == MSP then
      notify("info", "Enabled MSP")
      return true
    end -- if
  end -- if
end -- function OnPluginTelnetRequest

function OnPluginTelnetSubnegotiation (type, data)
   if type == GMCP then
    gmcp_handler(data)
  end -- if
end -- function OnPluginTelnetSubnegotiation

function OnPluginBroadcast(msg, id, name, text)
  
  if id == "54846c23d8b15594e7eb4b8a" then
    if text=="output_boundary" then
      mplay("misc/boundary")
          end
  elseif id == "706cd88f4d441a81439bd421" or id == "79772f9b67c1e42f22a3eb95" then
    if msg == 777 then
      -- successful update
      mplay("music/theme")

      -- Check if we should open the changelog
      if config:get_option("automatic_changelog").value == "yes" then
        -- Try to parse the broadcast data as JSON to get file list and channel
        local files = nil
        local channel = nil
        if text and text ~= "success" then
          local ok, data = pcall(json.decode.decode, text)
          if ok and data then
            if data.files then
              files = data.files
            end
            if data.channel then
              channel = data.channel
            end
          end
        end

        -- Open changelog with optional file list and channel
        notepad_changelog(nil, nil, nil, files, channel)
      end
    elseif msg == 888 then
      mplay("misc/updateAvailable")
    elseif msg == 999 then
      mplay("misc/alreadyUpToDate")
end
  elseif id == "843d2f53cb3685465bda7d4c" then
    local message_type, data = text:match("([^|]+)|?(.*)")
    message_type = message_type or text
    
    if message_type == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = data:match("([^,]+),?([^,]*)")
      if group_name then
        -- Add to config.audio table for F10 cycling (preserve existing volume if group exists)
        if not config.audio[group_name] then
          config.audio[group_name] = {volume=50, pan=0}
        end

        -- Also add the config option for persistence (preserve existing value)
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          -- Use existing volume from config.audio if available, otherwise default to 50
          local existing_volume = config.audio[group_name] and config.audio[group_name].volume or 50
          config:add_option("volume", option_name, display_name, existing_volume, "number", "volume")
        end
      end
    elseif message_type == "unregister_audio_group" then
      -- Remove audio group (format: "groupname")
      if data and config.audio[data] then
        config.audio[data] = nil
      end
    elseif message_type == "play_sound" then
      -- Parse sound file and group from data (format: "filepath,group")
      local filepath, group = data:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    elseif message_type == "set_audio_volume" then
      -- Set audio group volume (format: "groupname,volume")
      local group_name, volume = data:match("([^,]+),([^,]+)")
      if group_name and volume then
        local vol_num = tonumber(volume)
        if vol_num and config.audio[group_name] then
          config:set_attribute(group_name, "volume", vol_num)
        end
      end
    elseif message_type == "get_audio_volume" then
      -- Get audio group volume and broadcast back (format: "groupname")
      local group_name = data
      if group_name and config.audio[group_name] then
        local volume = config:get_attribute(group_name, "volume") or 100
        BroadcastPlugin(999, "audio_volume_reply|" .. group_name .. "," .. volume)
      end
    end
  elseif id == UPDATE_ID then
    -- Updater plugin communication (legacy support)
    local info = json.decode.decode(text)

    for i, u in pairs(info.update) do
      local name = u[i]

      if type(name) == 'string' and string.find(name, "updater.xml") then
        notify("important", "The updater received an update. In order to apply changes, you must reload the plugin.\ntype: `toastush:updater-reload'")
        break
      end -- if
    end -- for

    -- Note: automatic_changelog is now handled by update_watcher.xml (msg 777)
    -- to include the list of updated files
  else
    -- Other generic plugin communication handlers
    if msg == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = text:match("([^,]+),?([^,]*)")
      if group_name then
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          config:add_option("volume", option_name, display_name, 100, "number", "volume")
        end
      end
    elseif msg == "play_sound" then
      -- Parse sound file and group from text (format: "filepath,group")
      local filepath, group = text:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    end
  end
end -- OnPluginBroadcast

function OnPluginCommandEntered(text)
  last_command_time = os.time()

  -- Handle blank lines for dialog system (aliases don't catch them)
  if dialog and dialog.is_active() and text == "" then
    dialog.handle_input("")
    return
  end

  if (searchingScan) then
    searchingScan = false
    scan = nil
   classFilter = nil
  end -- if scan
end -- OnPluginCommandEnter

-- Combined with first OnPluginBroadcast function above


function gmcp_handler(data)

  -- Below follows a typical GMCP implementation.
  -- End users may wish to modify behavior.

  core, params = string.match(data, "([%a.]+)%s+(.*)")
  local info = json.decode(params)

  if core == "communication.channel" then
    Channel(info.channel, info.message, {"channels"})
  elseif core == "communication.say" then
    Channel("say", info.message, {"conversation"})
  elseif core == "communication.tell" then
    Channel("tell", info.message, {"tell"})
  end -- if
end -- gmcp_handler

function OnMSP(name, line, wc)

  local text = wc[1]
  local info = {
  file = string.match(text, "!![%u]+%(([%a%d%p]+).*%)"),
  type = string.match(text, "!![%u]+%(.*T=([%a%d]+).*%)"),
  volume = string.match(text, "!![%u]+%(.*V=([%d]+).*%)"),
  loop = string.match(text, "!![%u]+%(.*L=([%d]+).*%)"),
  continue = string.match(text, "!![%u]+%(.*C=([%d]+).*%)"),
  url = string.match(text, "!![%u]+%(.*U=([%a%d%p]+).*%)")
  }
  msp_handler(info)
end -- OnMSP

function msp_handler(info)

  -- Below follows a typical MSP implementation.
  -- End users may wish to modify behavior.

  play(info.file, info.type)
end -- msp_handler

function on_plugin_update()
  --  Externally called to indicate this plugin should be reloaded upon updates.
  return 1
end -- on_plugin_update

function janitor()

  -- Alert users of proxiani.
  local version = utils.split(VERSION, ".")
  if (tonumber(version[1]) < 3) then
    notify("info", [[

    Info: Beginning Toastush version 3.0.1 and onward, Toastush will now officially support popular Miriani proxy server, Proxiani.
    As a result, when the proxy server is detected, Toastush starmap commands will be disabled.
    Users can expect increased performance, shared features between clients, TLS connectivity and more!
    ]])

    notify("info",
    "See, "..PROXIANI.." for installation details.")

  end -- if

  -- plugins_updater no longer in use.

  local old_plugins = {
  ["fbd5b7cc1ef6acf827a3f4a1"] = "plugins_updater.xml",
  ["55e1d330539761f176fa0815"] = "indexer.xml", 
  } -- old_plugins

  -- old version downloaded messy files.
  local dir = utils.readdir("*.ogg")
  local js = require("json.decode")
  local f = io.open("index-v5.manifest", "r")

  if (f and dir) then
    local t = f:read("*all")
    f:close()
    local info = js.decode(t)

    local paths = ""
    for path, _ in pairs(info) do
      paths = paths.." "..path
    end -- for

    for file, _ in pairs(dir) do
      if string.find(paths, file) then
        utils.shellexecute("cmd", "/C rmdir "..file, GetInfo(59), nil, 0)
      end -- if
    end -- for
  end -- if
end -- janitor

function detect_update_when_idle()

  if config:get_option("update_idle").value == "yes"
  and IsPluginInstalled(UPDATE_ID)
  and last_command_time ~= nil
  and (os.time() - last_command_time) >= IDLE_CUTOFF then
    Execute("update quietly")
end -- if

end -- detect_update_when_idle

function toggle_minimal_mode(name, line, wc)
  local minimal_mode = (GetVariable("minimal_mode") == "1") and 1 or 0
  toggle_minimal_groups(minimal_mode)
  if (minimal_mode == 0) then


    SetVariable("minimal_mode", 1)
    notify("info", [[
    The soundpack is now in minimal mode.
    This mode disables the majority of triggers for a clean -- basic environment.
    Communications and miscellaneous gags will remain active.]])
  else

    DeleteVariable("minimal_mode")

    if (name == "minimal_mode_alias") then
      notify("info", "The soundpack is now in full -- regular mode.")
    end -- if
  end -- if
end -- minimal_mode

function toggle_minimal_groups(minimal_mode)
  for k,v in pairs(minimal_groups) do
    EnableGroup(v, minimal_mode)
  end -- for
  end -- toggle_minimal_groups

function initialize_audio()

  -- Clean up existing BASS instance if it exists
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end

  -- Initialize LUA Audio system
  Audio = require("miriani.lib.audio.audio")

  -- Initialize the audio system
  if Audio.BASS then
    BASS = Audio.BASS()

    -- Initialize BASS with retry logic for device switching
    if BASS then
      -- Flags: 1 (eight_bit) + 4 (three_d) = 5 (removed mono flag to get stereo by default)
      local init_result = BASS:Init(-1,44100,5)

      if init_result ~= 0 then
        -- Error codes: 4 = buffer_lost, 23 = device (illegal device number)
        -- 3 = driver (can't find free/valid driver)
        if init_result == 4 or init_result == 23 or init_result == 3 then
          Note("BASS device error (code " .. tostring(init_result) .. "), retrying with default device...")
          -- Free any partial initialization
          BASS:Free()
          -- Reinitialize BASS
          BASS = Audio.BASS()
          init_result = BASS:Init(-1,44100,5)
          if init_result ~= 0 then
            Note("BASS initialization retry failed with error: " .. tostring(init_result))
          else
            Note("BASS initialized successfully on retry")
          end
        else
          Note("BASS initialization failed with error: " .. tostring(init_result))
        end
      end
    end
  else
    Note("Audio.BASS not available")
  end

  local init_result = config:init(sp_options, audio_options)
  if init_result ~= 0 then
    print("Warning: Config initialization failed with code:", init_result)
    print("Continuing with basic initialization...")
  end

  if audio and audio.const and audio.const.device then
    local channels = audio.const.device.stereo
    audio:Init(nil, nil, channels)
  end

end -- initialize_audio


-- Load the new terminal-based config menu module
local config_menu_module = require(scripts.."config_menu")

function config_secondary_menu(option)
  -- Use new terminal-based menu system
  config_menu_module.show_group(option)
end -- config_secondary_menu


function config_main_menu()
  -- Use new terminal-based menu system
  config_menu_module.show_main()
end -- config_main_menu

function config_option_direct(group, option)
  -- Directly access an option by partial name or index
  config_menu_module.find_and_edit(group, option)
end -- config_option_direct

link = {}
infobar_t = {}


---------------------------------

function infobar(id, message, clear)
  id = id or 1

  if clear or message == "" then
    infobar_t[id] = nil
  end -- if


  local foreground = RGBColourToName(config:get_option("info_foreground_color").value)
  local background = RGBColourToName(config:get_option("info_background_color").value)
  local data = {}
  infobar_t[id] = message

  table.foreach(infobar_t,
  function (k, v)
    data[#(data) + 1] = v
  end ) -- foreach
 
  InfoClear()
  InfoColour(foreground)
  InfoBackground(background)

  Info(
  table.concat(data, " -- "))

end -- infobar

function latency(name, line, wildcard)
  local ms = tonumber(wildcard[1]) or 0
  infobar("lag", string.format ("Latency: %d MS", ms))
end -- latency

function show_paralyzed(roundtime, stuntime)
  local roundtime = roundtime or 0
  local stuntime = stuntime or 0
  local paralyzed = roundtime + stuntime
  local sec = (paralyzed == 1) and "second" or "seconds"
  local id = "paralyzed"
  if (paralyzed > 0) then
  infobar(id, string.format ("paralyzed: %d %s", paralyzed, sec))
  else
    infobar(id, "")
  end
end -- show_paralyzed

function help(name, line, wc)
  notify("info", string.format("%s", GetPluginInfo(GetPluginID(), 3)))
end-- help

function info(name, line, wc)
  local ID = GetPluginID()
  notify("info", string.format("%s  --  version %s  --  Scripting-language: %s  -- Script-time: %s seconds",
  GetPluginInfo(ID, 1),
  version.full_version_string(),
  GetPluginInfo(ID, 5),
  GetPluginInfo(ID, 24)))
end -- info

function channel(name, line, wc)

  -- Requires the channel history plugin.

  assert (IsPluginInstalled ("6000a4c6f0e71d31fecf523d"), "channel_history could not be found")

  if originating_from_camera(line) and name ~= "camera" then
  -- Don't duplicate camera messages in other buffers.
        return
  end -- camera
  -- add record table of channel arguments
   for k,v in ipairs(wc) do
    -- Handle metaf buffers
    if string.match(v, "^metaf ") then
      -- Check if separate buffers is enabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "yes" then
        -- Use frequency/label-specific buffer (no need to check metaf_buffer)
        Execute("history_add " .. v .. "=" .. line)
      else
        -- Use single metaf buffer if it's enabled
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
    elseif v == "metaf" then
      -- Regular metaf without frequency/label - only use if separate buffers is disabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "no" then
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
      -- If separate buffers is enabled, ignore plain "metaf" completely
    else
      -- Normal buffer handling
      buffer = config:get_option(string.format("%s_buffer", v))
      if buffer ~= nil and buffer.value == "yes" then
        Execute("history_add "..v.."="..line)
      end
    end -- if metaf
  end -- for loop
end -- channel

function OnPluginLineReceived(line)
  if GetVariable("logged_in") ~= "1" then
    return true
  end
  if not line:find("://", 1, true) then
    return true
  end
  local url = line:match("(https?://[^%s\"]+)") or
              line:match("(ftp://[^%s\"]+)") or
              line:match("(telnet://[^%s\"]+)") or
              line:match("(rsync://[^%s\"]+)") or
              line:match("(mailto:[^%s\"]+)") or
              line:match("(gopher://[^%s\"]+)")
  if url then
    channel("url", url, {"url"})
    link = {
      url = url,
      timestamp = os.clock()
    }
  end
  return true
end

function open_url()
  if not link or not link.timestamp
  or os.clock() - link.timestamp > timeout then
    notify("info", "No url to open.")
  else
    local url = link.url
    notify("info", "Opening "..url, 1)
    play("audio/mouseClick.ogg")
    OpenBrowser(url)
  end -- if
end -- open_url

function mplay(file, group, interrupt, pan, loop, slide, sec, frequency, volume_offset)
  -- DND mode: Block all sounds when Do Not Disturb is enabled
  if config and config:is_dnd() then
    return
  end

  if group == "babies" and originating_from_emote() then
    return
  end

  -- Miriani only play:
  local filepath

  -- Only check for alternate files if the alternate folder exists
  if has_alternate_audio then
    local path = require("pl.path")
    local dir, fn = path.splitpath(file)
    if (path.isfile(config:get("SOUND_DIRECTORY")..ALTPATH..dir.."/"..fn..ALT_EXTENSION)) then
      filepath = ALTPATH..dir.."/"..fn..ALT_EXTENSION
    end -- if
  end -- if

  if (not filepath) then
    filepath = string.format(SOUNDPATH.."%s%s", file, EXTENSION)
  end -- if

  play(filepath, group, interrupt, pan, loop, slide, sec, nil, volume_offset, frequency)
end -- mplay

function speech_interrupt(line)
  Execute("tts_interrupt "..line)
end -- speech_interrupt

function register()
  Send("#$#REGISTER_SOUNDPACK "..registry.." | "..VERSION.."\n")
  if not last_register_time or os.time() - last_register_time > 10 then
    mplay("misc/negotiate", "notification")
  end -- time
  last_register_time = os.time()
end -- register

function GetAudioVolume(group_name)
  -- Function for other plugins to call directly
  if group_name and config.audio[group_name] then
    return tostring(config:get_attribute(group_name, "volume") or 100)
  end
  return ""
end -- GetAudioVolume

function playstep(name, line, wildcards)
  local check_line = line or name

  if (not foundstep) or (not environment) or (not room) then
    return 0
  end -- if

  if check_line and originating_from_camera(check_line) then
    foundstep = false
    return 0
  end -- if

  foundstep = false

    -- Play social sounds for certain walk styles
    if footstep == "bounce" then
      mplay("social/neuter/bounce", "socials")
      return 1
    elseif footstep == "hop" or footstep == "leap" then
      local gender = math.random(2) == 1 and "male" or "female"
      mplay("social/" .. gender .. "/hop", "socials")
      return 1
    end

  -- Stop here if aquatic
  if environment.marine
  or string.find (room, "aquatic") then
    mplay ("steps/swim")
    return 1
  end -- if

  local file
  local function set_type(t, type, check)
    local ok
    for _, keyword in ipairs(t) do
      if string.find(string.lower(check), keyword) then
        file = type
        ok = 1
        break
      end -- if
    end -- for

    return ok
  end -- check_type

  local deserts = {"desert", "beach", "shore", "sand", "wasteland"}
  local forests = {"forest", "woods", "field", "grass", "jungle", "glade", "dale", "farm", "glen"}
  local muddy = {"mud", "swamp", "marsh"}
  local flying = {"fly", "float", "hover"}
  local ducts = {"duct", "crawlspace"}
  local skating = {"skate", "rollerblade"}


  if set_type(deserts, "desert", room) == 1
  or set_type(forests, "forest", room) == 1
  or set_type(muddy, "mud", room) == 1
  or set_type(ducts, "duct", room) == 1
  or set_type(flying, "fly", footstep) == 1
  or set_type(skating, "skate", footstep) == 1 then
    mplay("steps/"..file)
    return 1
  end -- if

  -- play sounds if environment is starship.
  if environment.name == "starship" then
    mplay ("steps/starship")
    return 1
  end -- if

  -- play sound if environment is station 
  if environment.name == "station" then
    mplay ("steps/station")
    return 1
  end -- if

  if environment.indoors then
    mplay("steps/planet/indoors")
  else
    mplay("steps/planet/outdoors")
  end -- if

  return 1
end -- playstep

function gagline(name, line, wc)
  if config:get_option("spam").value == "no" then
    print(line)
  else
  return 1
  end -- if

end -- gagline

function notepad_changelog(name, line, wc, updated_files, channel)

  local content = ""

  -- If updated files list is provided, add it at the top
  if updated_files and type(updated_files) == "table" and #updated_files > 0 then
    content = "Updated Files:\r\n"
    content = content .. string.rep("-", 50) .. "\r\n"
    for i, file in ipairs(updated_files) do
      content = content .. i .. ". " .. file .. "\r\n"
    end
    content = content .. string.rep("-", 50) .. "\r\n\r\n"
  end

    local f = io.open(GetInfo(66).."docs/changelog.md", "r")
    if (f) then
      local text = f:read("*all")
      f:close()
      content = content .. string.gsub(text, "\n", "\r\n")
    end -- if

  -- Only open the notepad if we have content to show
  if content ~= "" then
    AppendToNotepad("Changelog", content, "\r\n")
    ActivateNotepad("Changelog")
    NotepadSaveMethod ("Changelog", 2)
  end
end -- notepad_changelog

function replicate_line(line)
  Simulate("\r\n"..line.."\r\n")
end -- replicate_line

function print_hyperlink(l, text, hint, browser)
  browser = browser or 1
  local foreground = RGBColourToName(config:get_option("hyperlink_foreground_color").value)
  local background = RGBColourToName(config:get_option("hyperlink_background_color").value)

  Hyperlink(l, text, hint, foreground, background, browser)
  Note()

end -- print_hyperlink

function print_color(...)
  -- print lines with predefined colors:
  local content = {}

  for k,v in pairs({...}) do

    local group = v[2] or "default"
    content[#(content)+1] = RGBColourToName(
  config:get_option(group.."_color").value or 0)

    content[#(content)+1] = RGBColourToName(
    config:get_option("background_color").value)
    content[#(content)+1] = v[1]
  end -- for
  ColourNote(unpack(content))
end -- print_color

function format_coords(coords_str)
  local result = string.gsub(coords_str, "[()]", "")  -- Always strip parentheses
  if config:get_option("format_coordinates").value == "yes" then
    result = string.gsub(result, ", ", " ")
  end
  return result
end

function originating_from_camera(line)
  if GetVariable("last_camera_line") and GetVariable("last_camera_line") == line then
  DeleteVariable("last_camera_line")
  return true
  end -- GetVariable
  return false
end

function originating_from_emote()
  return os.clock() - (last_emote_time or 0) < 0.1
end

function handle_alt_space()
  -- Check config option
  if config:get_option("alt_space_shows_exits").value == "yes" then
    -- Show exits
    if current_exits == nil then
      Execute("tts_note No exit information available.")
    elseif #current_exits == 0 then
      Execute("tts_note No exits.")
    else
      -- Join exits with spaces only (no commas or "and")
      local exits_list = table.concat(current_exits, " ")
      Execute("tts_note " .. exits_list)
    end
  else
    -- Fall back to history behavior
    Execute("history_msgprev 0")
  end
end -- handle_alt_space
]]>
</script>


</muclient>
