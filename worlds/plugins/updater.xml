<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Update Plugin - Control the Miriani-Next updater binary -->

<muclient>
<plugin
   name="updater"
   author="distantorigin"
   id="706cd88f4d441a81439bd421"
   language="Lua"
   purpose="Control the update.exe updater binary"
   date_written="2025-10-27"
   requires="5.07"
   version="1.0"
   >

<description trim="y">
Update Plugin - Control the Miriani-Next updater binary

Commands:
  update switch              - Opens the channel switcher interactively
  update switch &lt;dev|stable&gt; - Switches to specified channel non-interactively
  update check               - Checks for updates without installing
  update version             - Shows the updater version
  update install             - Downloads and installs the updater if not present
  update help                - Shows this help
  update                     - With no arguments, checks for and performs an update with restart confirmation if needed
</description>

</plugin>

<aliases>

<alias
  enabled="y"
  match="^update( .*)?$"
  regexp="y"
  script="update_dispatcher"
  send_to="12"
  sequence="100"
>
</alias>

</aliases>

<script>
<![CDATA[

execute = require("execute")
async = require("async")

function OnPluginInstall()
 AcceleratorTo("ctrl+u", "update_run()", sendto.script)
end

function check_updater_exists()
  local homedir = GetInfo(66)
  local updater_path = homedir .. "update.exe"

  local file = io.open(updater_path, "r")
  if file then
    file:close()
    return true
  end
  return false
end

function download_updater(callback)
  local homedir = GetInfo(66)
  local download_url = "https://anomalousabode.com/next/updater"

  Note("Downloading updater...")

  async.doAsyncRemoteRequest(download_url, function(retval, page, status, headers, full_status, requested_url)
    if not retval or status ~= 200 then
      Note("Error: Failed to download update.exe (HTTP " .. tostring(status) .. ")")
      if callback then callback(false) end
      return
    end

    local updater_path = homedir .. "update.exe"
    local file = io.open(updater_path, "wb")
    if not file then
      Note("Error: Failed to write update.exe to " .. updater_path)
      if callback then callback(false) end
      return
    end

    file:write(page)
    file:close()

    Note("Successfully downloaded update.exe to " .. homedir)
    if callback then callback(true) end
  end, "HTTPS", 60, function(url, timeout)
    Note("Error: Download timed out after " .. timeout .. " seconds")
    if callback then callback(false) end
  end)
end

function get_current_channel()
  local homedir = GetInfo(66)
  local channel_file = homedir .. ".update-channel"

  local file = io.open(channel_file, "r")
  if not file then
    return "stable"
  end

  local channel = file:read("*all")
  file:close()

  channel = channel:match("^%s*(.-)%s*$")
  return channel or "stable"
end

function parse_check_output(output_lines)
  local info = {
    update_available = false,
    restart_required = false,
    version = nil,
    channel = nil,
    changes = 0
  }

  for _, line in ipairs(output_lines) do
    if line:match("Update available: Yes") then
      info.update_available = true
    elseif line:match("Restart required: Yes") then
      info.restart_required = true
    elseif line:match("Version: (.+)") then
      info.version = line:match("Version: (.+)")
    elseif line:match("Channel: (.+)") then
      info.channel = line:match("Channel: (.+)")
    elseif line:match("Changes: (%d+)") then
      info.changes = tonumber(line:match("Changes: (%d+)"))
    end
  end

  return info
end

function run_updater_hidden(args, callback)
  if not check_updater_exists() then
    Note("Error: update.exe not found. Please run 'update install' to download it.")
    if callback then callback(false, {}, -1) end
    return
  end

  local homedir = GetInfo(66)
  local cmd = homedir .. "update.exe " .. args .. " -non-interactive"

  execute.doAsyncExecute(cmd, function(success, output, exit_code, err)
    if success then
      if callback then callback(success, output, exit_code) end
    else
      Note("Updater error: " .. (err or "Unknown error"))
      if callback then callback(false, {}, exit_code or -1) end
    end
  end, {
    hide_window = true,
    working_dir = homedir,
    timeout = 60
  })
end

function run_updater_visible(args)
  if not check_updater_exists() then
    Note("Error: update.exe not found. Please run 'update install' to download it.")
    return
  end

  local homedir = GetInfo(66)
  local cmd = "update.exe"
  utils.shellexecute(cmd, args, homedir, "open", 1)
end

function update_dispatcher(name, line, wildcards)

  local args = wildcards[1]

  if args then
    args = args:match("^%s*(.-)%s*$")
  end

  -- Parse the command
  if not args or args == "" then
    -- No arguments, run update
    update_run()
  else
    -- Split args into command and parameters
    local cmd, params = args:match("^(%S+)%s*(.-)$")

    if cmd == "install" then
      if check_updater_exists() then
        Note("update.exe already exists. No need to download.")
      else
        download_updater(function(success)
          if success then
            Note("Installation complete. Running update check...")
            update_run()
          else
            Note("Installation failed.")
          end
        end)
      end

    if cmd == "install" then
        download_updater(function(success)
          if success then
            Note("Reinstallation complete. Running update check...")
            update_run()
          else
            Note("Reinstallation failed.")
          end
        end)
      end

    elseif cmd == "switch" then
      if params == "" then
        -- Interactive switch
        run_updater_visible("switch")
      elseif params == "dev" or params == "stable" then
        -- Switch to specific channel
        run_updater_hidden("switch " .. params, function(success, output, exit_code)
          if success and #output > 0 then
            for _, line in ipairs(output) do
              Note(line)
            end
          else
            Note("Error: Failed to switch channel")
          end
        end)
      else
        Note("Invalid channel. Use 'dev' or 'stable'.")
      end

    elseif cmd == "check" then
      run_updater_hidden("check", function(success, output, exit_code)
        if success and #output > 0 then
          for _, line in ipairs(output) do
            Note(line)
          end
        else
          Note("Error: Failed to check for updates")
        end
      end)

    elseif cmd == "version" or cmd == "-v" then
      run_updater_hidden("-version", function(success, output, exit_code)
        if success and #output > 0 then
          for _, line in ipairs(output) do
            Note(line)
          end
        else
          Note("Error: Failed to get updater version")
        end
      end)

    elseif cmd == "help" or cmd == "-h" or cmd == "--help" then
      Note(GetPluginInfo(GetPluginID(), 3))

    else
      Note("Invalid command. Type 'update help' for usage.")
    end
  end
end

-- Main update function (with restart check)
function update_run()
  Note("Checking for updates...")

  -- First, check if updates are available (hidden, no console flash!)
  run_updater_hidden("check", function(success, output, exit_code)
    if not success or not output or #output == 0 then
      Note("Error: Failed to check for updates")
      return
    end

    local info = parse_check_output(output)

    if not info.update_available then
      Note("Already up to date!")
      return
    end

    -- Get the current channel
    local channel = get_current_channel()

    -- Build the message
    local message = "A new update is available on the " .. channel .. " channel! Would you like to install it now?"

    if info.restart_required then
      message = message .. "\n\nNote: This update requires MUSHclient to be restarted."
    end

    -- Build the title
    local title = "Update Available"
    if info.version then
      title = "Update to Version " .. info.version
    end

    -- Ask user for confirmation
    local response = utils.msgbox(message, title, "yesno", "?", 1)

    if response == "yes" then
      Note("Starting update...")

      -- Run the update
      if info.restart_required then
        -- Use -allow-restart flag if restart is required
        run_updater_visible("-allow-restart -non-interactive")
      else
        -- Run without restart flag
run_updater_visible("-non-interactive")
--        run_updater_hidden("", function(output, exit_code)
-- if exit_code == 0 then
--            Note("Update completed successfully!")
--          else
--            Note("Update failed with exit code: " .. tostring(exit_code))
--          end
          -- Show all output regardless of exit code
--          if output and #output > 0 then
--            for _, line in ipairs(output) do
--              Note(line)
--            end
--          end
--        end)
      end
    else
      Note("Update cancelled.")
    end
  end)
end

]]>
</script>

</muclient>
